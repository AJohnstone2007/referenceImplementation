
translation_unit ::=
  declaration_seq?  
// Generated by gramex V3.0 from 'ansi_cpp_prd97.raw' (this build Mar 25 2012 at 13:21:48)
// Command line: C:\csle\dev\gramex\gramex.exe ansi_cpp_prd97.raw

// M()(translation_unit)

// Start of provenance

// ansi_cpp_prd97.raw - a grammar for the 1998 ANSI C++ standard language

// 1. This is the grammar summary from the 1997 Public Review Document for
// ANSI C++, cut-and-pasted from http://www.open-std.org/jtc1/sc22/open/n2356/ 
// on 30 August 2006.

// 2. There may be differences between this grammar and the one in the final 
// published standard. 

// 3. You can process this file with the gramex tool to make something close
// to a Bison input file, and use the gramconv tool to convert EBNF
// constructs to pure BNF, and to translate to a variety of other formats.

// 4. For tool and grammar downloads, see the Royal Holloway Compilers Group
// homepage under http://www.cs.rhul.ac.uk, or contact us at
// A.Johnstone@rhul.ac.uk or E.Scott@rhul.ac.uk.

// 5. Please don't change this file.

//         Adrian Johnstone and Elizabeth Scott, 24 August 2006

// End of provenance
//   ______________________________________________________________________

//   Annex 0 (informative)

//   Grammar summary                                                 [gram]

//   ______________________________________________________________________

// 1 This summary of C++ syntax is intended to be an aid to  comprehension.
//   It  is  not  an  exact  statement of the language.  In particular, the
//   grammar described here accepts a superset  of  valid  C++  constructs.
//   Disambiguation rules (_stmt.ambig_, _dcl.spec_, _class.member.lookup_)
//   must be applied to distinguish expressions  from  declarations.   Fur-
//   ther,  access  control, ambiguity, and type rules must be used to weed
//   out syntactically valid but meaningless constructs.

//   1.1  Keywords                                               [gram.key]

// 1 New context-dependent keywords are introduced into a program by  type-
//   def  (_dcl.typedef_),  namespace  (_namespace.def_),  class (_class_),
//   enumeration (_dcl.enum_), and template (_temp_) declarations.
(* Comment out lexical material 

typedef_name ::=
  identifier  
namespace_name ::=
  original_namespace_name |
  namespace_alias  

original_namespace_name ::=
  identifier  

namespace_alias ::=
  identifier  
class_name ::=
  identifier |
  template_id  
enum_name ::=
  identifier  
template_name ::=
  identifier |
  'Note' 'that' 'a' typedef_name 'naming' 'a' 'class' 'is' 'also' 'a' class_name |
  '(_class.name_).'  

//   1.2  Lexical conventions                                    [gram.lex]
hex_quad ::=
  hexadecimal_digit hexadecimal_digit hexadecimal_digit hexadecimal_digit  

universal_character_name ::=
  '\\u' hex_quad |
  '\\U' hex_quad hex_quad  

preprocessing_token ::=
  header_name |
  identifier |
  pp_number |
  character_literal |
  string_literal |
  preprocessing_op_or_punc |
  'each' 'non-white-space' 'character' 'that' 'cannot' 'be' 'one' 'of' 'the' 'above'  
token ::=
  identifier |
  'keyword' |
  literal |
  operator |
  'punctuator'  
header_name ::=
  '<h-char-sequence>' |
  '\"q-char-sequence\"'  
h_char_sequence ::=
  h_char |
  h_char_sequence h_char  
h_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  new_line 'and' '>'  
q_char_sequence ::=
  q_char |
  q_char_sequence q_char  
q_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  new_line 'and' '\"'  
pp_number ::=
  digit |
  '.' digit |
  pp_number digit |
  pp_number nondigit |
  pp_number 'e' sign |
  pp_number 'E' sign |
  pp_number '.'  
identifier ::=
  nondigit |
  identifier nondigit |
  identifier digit  
nondigit ::=
  universal_character_name |
  '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' |
  'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' |
  'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'  
digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'  

preprocessing_op_or_punc ::=
  '{' | '}' | '[' | ']' | '#' | '##' | '(' | ')' |
  '<:' | ':>' | '<%' | '%>' | '%:' | '%:%:' | ';' | ':' | '...' |
  'new' | 'delete' | '?' | '::' | '.' | '.*' |
  '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' |
  '!' | '=' | '<' | '>' | '+=' | '-=' | '*=' | '/=' | '%=' |
  '^=' | '&=' | '|=' | '<<' | '>>' | '>>=' | '<<=' | '==' | '!=' |
  '<=' | '>=' | '&&' | '||' | '++' | '--' | ',' | '->*' | '->' |
  'and' | 'and_eq' | 'bitand' | 'bitor' | 'compl' | 'not' | 'not_eq' | 'or' | 'or_eq' |
  'xor' | 'xor_eq'  

literal ::=
  integer_literal |
  character_literal |
  floating_literal |
  string_literal |
  boolean_literal  
integer_literal ::=
  decimal_literal integer_suffix? |
  octal_literal integer_suffix? |
  hexadecimal_literal integer_suffix?  
decimal_literal ::=
  nonzero_digit |
  decimal_literal digit  
octal_literal ::=
  '0' |
  octal_literal octal_digit  
hexadecimal_literal ::=
  '0x' hexadecimal_digit |
  '0X' hexadecimal_digit |
  hexadecimal_literal hexadecimal_digit  
nonzero_digit ::=
  '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'  
octal_digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'  
hexadecimal_digit ::=
  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' |
  'a' | 'b' | 'c' | 'd' | 'e' | 'f' |
  'A' | 'B' | 'C' | 'D' | 'E' | 'F'  
integer_suffix ::=
  unsigned_suffix long_suffix? |
  long_suffix unsigned_suffix?  
unsigned_suffix ::=
  'u' | 'U'  
long_suffix ::=
  'l' | 'L'  
character_literal ::=
  '\'c-char-sequence\'' |
  'L\'c-char-sequence\''  
c_char_sequence ::=
  c_char |
  c_char_sequence c_char  

c_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  'the' 'single-quote' '\',' 'backslash' '\\,' 'or' new_line 'character' |
  escape_sequence |
  universal_character_name  
escape_sequence ::=
  simple_escape_sequence |
  octal_escape_sequence |
  hexadecimal_escape_sequence  
simple_escape_sequence ::=
  '\\\'' | '\\\"' | '\\?' | '\\\\' |
  '\\a' | '\\b' | '\\f' | '\\n' | '\\r' | '\\t' | '\\v'  
octal_escape_sequence ::=
  '\\' octal_digit |
  '\\' octal_digit octal_digit |
  '\\' octal_digit octal_digit octal_digit  
hexadecimal_escape_sequence ::=
  '\\x' hexadecimal_digit |
  hexadecimal_escape_sequence hexadecimal_digit  
floating_literal ::=
  fractional_constant exponent_part? floating_suffix? |
  digit_sequence exponent_part floating_suffix?  
fractional_constant ::=
  digit_sequence? '.' digit_sequence |
  digit_sequence '.'  
exponent_part ::=
  'e' sign? digit_sequence |
  'E' sign? digit_sequence  
sign ::=
  '+' | '-'  
digit_sequence ::=
  digit |
  digit_sequence digit  
floating_suffix ::=
  'f' | 'l' | 'F' | 'L'  
string_literal ::=
  '\"s-char-sequenceopt\"' |
  'L\"s-char-sequenceopt\"'  
s_char_sequence ::=
  s_char |
  s_char_sequence s_char  
s_char ::=
  'any' 'member' 'of' 'the' 'source' 'character' 'set' 'except' |
  'the' 'double-quote' '\",' 'backslash' '\\,' 'or' new_line 'character' |
  escape_sequence |
  universal_character_name  
boolean_literal ::=
  'false' |
  'true'  
*)
literal ::=
  integer_literal |
  character_literal |
  floating_literal |
  string_literal |
  boolean_literal  

string_literal ::= 'STRING' | string_literal 'STRING'   (* Allow C-style String catenation *)
character_literal ::= 'CHARACTER'  
integer_literal ::= 'INTEGER'  
floating_literal ::= 'REAL'  
boolean_literal ::= 'true' | 'false'  

identifier ::= 'ID'  

//   1.3  Basic concepts                                       [gram.basic]
//translation_unit ::=
//  declaration_seq?  

//   1.4  Expressions                                           [gram.expr]
primary_expression ::=
  literal |
  'this' |
  '::' identifier |
  '::' operator_function_id |
  '::' qualified_id |
  '(' expression ')' |
  id_expression  

(* Comment out unexpected duplicate production
id_expression ::=
  unqualified_id |
  qualified_id  
*)

id_expression ::=
  unqualified_id |
  qualified_id  

unqualified_id ::=
  identifier |
  operator_function_id |
  conversion_function_id |
  '~' class_name |
  template_id  
qualified_id ::=
  nested_name_specifier 'template'? unqualified_id  
nested_name_specifier ::=
  class_or_namespace_name '::' nested_name_specifier?  

class_or_namespace_name ::=
  class_name |
  namespace_name  
postfix_expression ::=
  primary_expression |
  postfix_expression '[' expression ']' |
  postfix_expression '(' expression_list? ')' |
  simple_type_specifier '(' expression_list? ')' |
  postfix_expression '.' 'template'? '::'? id_expression |
  postfix_expression '->' 'template'? '::'? id_expression |
  postfix_expression '.' pseudo_destructor_name |
  postfix_expression '->' pseudo_destructor_name |
  postfix_expression '++' |
  postfix_expression '--' |
  'dynamic_cast' '<' type_id '>' '(' expression ')' |
  'static_cast' '<' type_id '>' '(' expression ')' |
  'reinterpret_cast' '<' type_id '>' '(' expression ')' |
  'const_cast' '<' type_id '>' '(' expression ')' |
  'typeid' '(' expression ')' |
  'typeid' '(' type_id ')'  

expression_list ::=
  assignment_expression |
  expression_list ',' assignment_expression  
pseudo_destructor_name ::=
  '::'? nested_name_specifier? type_name '::' '~' type_name |
  '::'? nested_name_specifier? '~' type_name  
unary_expression ::=
  postfix_expression |
  '++' cast_expression |
  '--' cast_expression |
  unary_operator cast_expression |
  'sizeof' unary_expression |
  'sizeof' '(' type_id ')' |
  new_expression |
  delete_expression  
unary_operator ::=
  '*' | '&' | '+' | '-' | '!' | '~'  
new_expression ::=
  '::'? 'new' new_placement? new_type_id new_initializer? |
  '::'? 'new' new_placement? '(' type_id ')' new_initializer?  
new_placement ::=
  '(' expression_list ')'  
new_type_id ::=
  type_specifier_seq new_declarator?  
new_declarator ::=
  ptr_operator new_declarator? |
  direct_new_declarator  
direct_new_declarator ::=
  '[' expression ']' |
  direct_new_declarator '[' constant_expression ']'  
new_initializer ::=
  '(' expression_list? ')'  
delete_expression ::=
  '::'? 'delete' cast_expression |
  '::'? 'delete' '[' ']' cast_expression  
cast_expression ::=
  unary_expression |
  '(' type_id ')' cast_expression  
pm_expression ::=
  cast_expression |
  pm_expression '.*' cast_expression |
  pm_expression '->*' cast_expression  
multiplicative_expression ::=
  pm_expression |
  multiplicative_expression '*' pm_expression |
  multiplicative_expression '/' pm_expression |
  multiplicative_expression '%' pm_expression  
additive_expression ::=
  multiplicative_expression |
  additive_expression '+' multiplicative_expression |
  additive_expression '-' multiplicative_expression  

shift_expression ::=
  additive_expression |
  shift_expression '<<' additive_expression |
  shift_expression '>>' additive_expression  
relational_expression ::=
  shift_expression |
  relational_expression '<' shift_expression |
  relational_expression '>' shift_expression |
  relational_expression '<=' shift_expression |
  relational_expression '>=' shift_expression  
equality_expression ::=
  relational_expression |
  equality_expression '==' relational_expression |
  equality_expression '!=' relational_expression  
and_expression ::=
  equality_expression |
  and_expression '&' equality_expression  
exclusive_or_expression ::=
  and_expression |
  exclusive_or_expression '^' and_expression  
inclusive_or_expression ::=
  exclusive_or_expression |
  inclusive_or_expression '|' exclusive_or_expression  
logical_and_expression ::=
  inclusive_or_expression |
  logical_and_expression '&&' inclusive_or_expression  
logical_or_expression ::=
  logical_and_expression |
  logical_or_expression '||' logical_and_expression  
conditional_expression ::=
  logical_or_expression |
  logical_or_expression '?' expression ':' assignment_expression  
assignment_expression ::=
  conditional_expression |
  logical_or_expression assignment_operator assignment_expression |
  throw_expression  
assignment_operator ::=
  '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '>>=' | '<<=' | '&=' | '^=' | '|='  
expression ::=
  assignment_expression |
  expression ',' assignment_expression  
constant_expression ::=
  conditional_expression  

//   1.5  Statements                                       [gram.stmt.stmt]
statement ::=
  labeled_statement |
  expression_statement |
  compound_statement |
  selection_statement |
  iteration_statement |
  jump_statement |
  declaration_statement |
  try_block  

labeled_statement ::=
  identifier ':' statement |
  'case' constant_expression ':' statement |
  'default' ':' statement  
expression_statement ::=
  expression? ';'  
compound_statement ::=
  '{' statement_seq? '}'  
statement_seq ::=
  statement |
  statement_seq statement  
selection_statement ::=
  'if' '(' condition ')' statement |
  'if' '(' condition ')' statement 'else' statement |
  'switch' '(' condition ')' statement  
condition ::=
  expression |
  type_specifier_seq declarator '=' assignment_expression  
iteration_statement ::=
  'while' '(' condition ')' statement |
  'do' statement 'while' '(' expression ')' ';' |
  'for' '(' for_init_statement condition? ';' expression? ')' statement  
for_init_statement ::=
  expression_statement |
  simple_declaration  
jump_statement ::=
  'break' ';' |
  'continue' ';' |
  'return' expression? ';' |
  'goto' identifier ';'  
declaration_statement ::=
  block_declaration  

//   1.6  Declarations                                       [gram.dcl.dcl]
declaration_seq ::=
  declaration |
  declaration_seq declaration  
declaration ::=
  block_declaration |
  function_definition |
  template_declaration |
  explicit_instantiation |
  explicit_specialization |
  linkage_specification |
  namespace_definition  
block_declaration ::=
  simple_declaration |
  asm_definition |
  namespace_alias_definition |
  using_declaration |
  using_directive  
simple_declaration ::=
  decl_specifier_seq? init_declarator_list? ';'  

decl_specifier ::=
  storage_class_specifier |
  type_specifier |
  function_specifier |
  'friend' |
  'typedef'  
decl_specifier_seq ::=
  decl_specifier_seq? decl_specifier  
storage_class_specifier ::=
  'auto' |
  'register' |
  'static' |
  'extern' |
  'mutable'  
function_specifier ::=
  'inline' |
  'virtual' |
  'explicit'  
typedef_name ::=
  identifier  
type_specifier ::=
  simple_type_specifier |
  class_specifier |
  enum_specifier |
  elaborated_type_specifier |
  cv_qualifier  
simple_type_specifier ::=
  '::'? nested_name_specifier? type_name |
  'char' |
  'wchar_t' |
  'bool' |
  'short' |
  'int' |
  'long' |
  'signed' |
  'unsigned' |
  'float' |
  'double' |
  'void'  
type_name ::=
  class_name |
  enum_name |
  typedef_name  
elaborated_type_specifier ::=
  class_key '::'? nested_name_specifier? identifier |
  'enum' '::'? nested_name_specifier? identifier |
  'typename' '::'? nested_name_specifier identifier |
  'typename' '::'? nested_name_specifier identifier '<' template_argument_list '>'  
enum_name ::=
  identifier  
enum_specifier ::=
  'enum' identifier? '{' enumerator_list? '}'  

enumerator_list ::=
  enumerator_definition |
  enumerator_list ',' enumerator_definition  
enumerator_definition ::=
  enumerator |
  enumerator '=' constant_expression  
enumerator ::=
  identifier  
namespace_name ::=
  original_namespace_name |
  namespace_alias  
original_namespace_name ::=
  identifier  

namespace_definition ::=
  named_namespace_definition |
  unnamed_namespace_definition  

named_namespace_definition ::=
  original_namespace_definition |
  extension_namespace_definition  

original_namespace_definition ::=
  'namespace' identifier '{' namespace_body '}'  

extension_namespace_definition ::=
  'namespace' original_namespace_name '{' namespace_body '}'  

unnamed_namespace_definition ::=
  'namespace' '{' namespace_body '}'  

namespace_body ::=
  declaration_seq?  
namespace_alias ::=
  identifier  

namespace_alias_definition ::=
  'namespace' identifier '=' qualified_namespace_specifier ';'  

qualified_namespace_specifier ::=
  '::'? nested_name_specifier? namespace_name  
using_declaration ::=
  'using' 'typename'? '::'? nested_name_specifier unqualified_id ';' |
  'using' '::' unqualified_id ';'  
using_directive ::=
  'using' 'namespace' '::'? nested_name_specifier? namespace_name ';'  
asm_definition ::=
  'asm' '(' string_literal ')' ';'  
linkage_specification ::=
  'extern' string_literal '{' declaration_seq? '}' |
  'extern' string_literal declaration  

//   1.7  Declarators                                       [gram.dcl.decl]
init_declarator_list ::=
  init_declarator |
  init_declarator_list ',' init_declarator  
init_declarator ::=
  declarator initializer?  
declarator ::=
  direct_declarator |
  ptr_operator declarator  
direct_declarator ::=
  declarator_id |
  direct_declarator '(' parameter_declaration_clause ')' cv_qualifier_seq? exception_specification? |
  direct_declarator '[' constant_expression? ']' |
  '(' declarator ')'  
ptr_operator ::=
  '*' cv_qualifier_seq? |
  '&' |
  '::'? nested_name_specifier '*' cv_qualifier_seq?  
cv_qualifier_seq ::=
  cv_qualifier cv_qualifier_seq?  
cv_qualifier ::=
  'const' |
  'volatile'  
declarator_id ::=
  '::'? id_expression |
  '::'? nested_name_specifier? type_name  
type_id ::=
  type_specifier_seq abstract_declarator?  
type_specifier_seq ::=
  type_specifier type_specifier_seq?  
abstract_declarator ::=
  ptr_operator abstract_declarator? |
  direct_abstract_declarator  
direct_abstract_declarator ::=
  direct_abstract_declarator? '(' parameter_declaration_clause ')' cv_qualifier_seq? exception_specification? |
  direct_abstract_declarator? '[' constant_expression? ']' |
  '(' abstract_declarator ')'  
parameter_declaration_clause ::=
  parameter_declaration_list? '...'? |
  parameter_declaration_list ',' '...'  
parameter_declaration_list ::=
  parameter_declaration |
  parameter_declaration_list ',' parameter_declaration  
parameter_declaration ::=
  decl_specifier_seq declarator |
  decl_specifier_seq declarator '=' assignment_expression |
  decl_specifier_seq abstract_declarator? |
  decl_specifier_seq abstract_declarator? '=' assignment_expression  
function_definition ::=
  decl_specifier_seq? declarator ctor_initializer? function_body |
  decl_specifier_seq? declarator function_try_block  

function_body ::=
  compound_statement  

initializer ::=
  '=' initializer_clause |
  '(' expression_list ')'  
initializer_clause ::=
  assignment_expression |
  '{' initializer_list ','? '}' |
  '{' '}'  
initializer_list ::=
  initializer_clause |
  initializer_list ',' initializer_clause  

//   1.8  Classes                                              [gram.class]
class_name ::=
  identifier |
  template_id  
class_specifier ::=
  class_head '{' member_specification? '}'  
class_head ::=
  class_key identifier? base_clause? |
  class_key nested_name_specifier identifier base_clause?  
class_key ::=
  'class' |
  'struct' |
  'union'  
member_specification ::=
  member_declaration member_specification? |
  access_specifier ':' member_specification?  
member_declaration ::=
  decl_specifier_seq? member_declarator_list? ';' |
  function_definition ';'? |
  qualified_id ';' |
  using_declaration |
  template_declaration  
member_declarator_list ::=
  member_declarator |
  member_declarator_list ',' member_declarator  
member_declarator ::=
  declarator pure_specifier? |
  declarator constant_initializer? |
  identifier? ':' constant_expression  
pure_specifier ::=
  '=' '0'  
constant_initializer ::=
  '=' constant_expression  

//   1.9  Derived classes                              [gram.class.derived]
base_clause ::=
  ':' base_specifier_list  
base_specifier_list ::=
  base_specifier |
  base_specifier_list ',' base_specifier  

base_specifier ::=
  '::'? nested_name_specifier? class_name |
  'virtual' access_specifier? '::'? nested_name_specifier? class_name |
  access_specifier 'virtual'? '::'? nested_name_specifier? class_name  
access_specifier ::=
  'private' |
  'protected' |
  'public'  

//   1.10  Special member functions                          [gram.special]
conversion_function_id ::=
  operator conversion_type_id  
conversion_type_id ::=
  type_specifier_seq conversion_declarator?  
conversion_declarator ::=
  ptr_operator conversion_declarator?  
ctor_initializer ::=
  ':' mem_initializer_list  
mem_initializer_list ::=
  mem_initializer |
  mem_initializer ',' mem_initializer_list  
mem_initializer ::=
  mem_initializer_id '(' expression_list? ')'  
mem_initializer_id ::=
  '::'? nested_name_specifier? class_name |
  identifier  

//   1.11  Overloading                                          [gram.over]
operator_function_id ::=
  operator operator  
operator ::=
  'new' | 'delete' | 'new[]' | 'delete[]' |
  '+' | '-' | '*' | '/' | '%' | '^' | '&' | '|' | '~' |
  '!' | '=' | '<' | '>' | '+=' | '-=' | '*=' | '/=' | '%=' |
  '^=' | '&=' | '|=' | '<<' | '>>' | '>>=' | '<<=' | '==' | '!=' |
  '<=' | '>=' | '&&' | '||' | '++' | '--' | ',' | '->*' | '->' |
  '()' | '[]'  

//   1.12  Templates                                            [gram.temp]
template_declaration ::=
  'export'? 'template' '<' template_parameter_list '>' declaration  
template_parameter_list ::=
  template_parameter |
  template_parameter_list ',' template_parameter  
template_parameter ::=
  type_parameter |
  parameter_declaration  
type_parameter ::=
  'class' identifier? |
  'class' identifier? '=' type_id |
  'typename' identifier? |
  'typename' identifier? '=' type_id |
  'template' '<' template_parameter_list '>' 'class' identifier? |
  'template' '<' template_parameter_list '>' 'class' identifier? '=' template_name  

template_id ::=
  template_name '<' template_argument_list '>'  
template_name ::=
  identifier  
template_argument_list ::=
  template_argument |
  template_argument_list ',' template_argument  
template_argument ::=
  assignment_expression |
  type_id |
  template_name  
explicit_instantiation ::=
  'template' declaration  
explicit_specialization ::=
  'template' '<' '>' declaration  

//   1.13  Exception handling                                 [gram.except]
try_block ::=
  'try' compound_statement handler_seq  
function_try_block ::=
  'try' ctor_initializer? function_body handler_seq  
handler_seq ::=
  handler handler_seq?  
handler ::=
  'catch' '(' exception_declaration ')' compound_statement  
exception_declaration ::=
  type_specifier_seq declarator |
  type_specifier_seq abstract_declarator |
  type_specifier_seq |
  '...'  
throw_expression ::=
  'throw' assignment_expression?  
exception_specification ::=
  'throw' '(' type_id_list? ')'  
type_id_list ::=
  type_id |
  type_id_list ',' type_id  

(* Comment out preprocessor stuff 
//   1.14  Preprocessing directives                              [gram.cpp]
preprocessing_file ::=
  group?  
group ::=
  group_part |
  group group_part  
group_part ::=
  pp_tokens? new_line |
  if_section |
  control_line  
if_section ::=
  if_group elif_groups? else_group? endif_line  
if_group ::=
  '#' 'if' constant_expression new_line group? |
  '#' 'ifdef' identifier new_line group? |
  '#' 'ifndef' identifier new_line group?  

elif_groups ::=
  elif_group |
  elif_groups elif_group  
elif_group ::=
  '#' 'elif' constant_expression new_line group?  
else_group ::=
  '#' 'else' new_line group?  
endif_line ::=
  '#' 'endif' new_line  
control_line ::=
  '#' 'include' pp_tokens new_line |
  '#' 'define' identifier replacement_list new_line |
  '#' 'define' identifier lparen 'identifier-list'? ')' replacement_list new_line |
  '#' 'undef' identifier new_line |
  '#' 'line' pp_tokens new_line |
  '#' 'error' pp_tokens? new_line |
  '#' 'pragma' pp_tokens? new_line |
  '#' new_line  
lparen ::=
  'the' 'left-parenthesis' 'character' 'without' 'preceding' 'white-space'  
replacement_list ::=
  pp_tokens?  
pp_tokens ::=
  preprocessing_token |
  pp_tokens preprocessing_token  
new_line ::=
  'the' new_line 'character'  
*)

// End of ansi_cpp_prd97.raw
 