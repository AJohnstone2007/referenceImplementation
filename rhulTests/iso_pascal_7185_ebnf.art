

program ::= program_heading ';' program_block '.'   

// Generated by gramex V3.0 from 'iso_pascal_7185.raw' (this build Jun  8 2012 at 15:37:41)
// Command line: C:\csle\dev\gramex\gramex.exe -p -c iso_pascal_7185.raw


(*6.7.3*)     actual_parameter ::= expression | variable_access | procedure_identifier 
                               | function_identifier   

(*6.7.3*)     actual_parameter_list ::= '(' actual_parameter ( ',' actual_parameter)* ')'   

(*6.7.2.1*)   adding_operator ::= '+' | '-'      | 'or'   

(*6.1.7*)     apostrophe_image ::= '"'    

(*6.4.3.2*)   array_type ::= 'array' '[' index_type ( ',' index_type)* ']' 'of' component_type   

(*6.5.3.2*)   array_variable ::= variable_access   

(*6.8.2.2*)   assignment_statement ::= ( variable_access | function_identifier ) ':=' expression   

(*6.4.3.4*)   base_type ::= ordinal_type   

(*6.2.1*)     block ::= label_declaration_part constant_definition_part type_definition_part 
                      variable_declaration_part procedure_and_function_declaration_part 
                      statement_part   

(*6.7.2.3*)   Boolean_expression ::= expression   

(*6.6.3.7.1*) bound_identifier ::= identifier   

(*6.5.5*)     buffer_variable ::= file_variable '^'    

(*6.4.3.3*)   case_constant ::= constant   

(*6.4.3.3*)   case_constant_list ::= case_constant ( ',' case_constant)*   

(*6.8.3.5*)   case_index ::= expression   

(*6.8.3.5*)   case_list_element ::= case_constant_list ':' statement   

(*6.8.3.5*)   case_statement ::= 'case' case_index 'of' case_list_element 
                               ( ';' case_list_element)* ( ';')? 'end'   

(*6.1.7*)     character_string ::= 'STRING'   (* '\'' string_element ( string_element)*'\''   *)

(*6.4.3.2*)   component_type ::= type_denoter   

(*6.5.3.1*)   component_variable ::= indexed_variable | field_designator   

(*6.8.3.2*)   compound_statement ::= 'begin' statement_sequence 'end'   

(*6.8.3.3*)   conditional_statement ::= if_statement | case_statement   

(*6.6.3.7.1*) conformant_array_parameter_specification ::= value_conformant_array_specification 
                                                       | variable_conformant_array_specification   

(*6.6.3.7.1*) conformant_array_schema ::= packed_conformant_array_schema 
                                      | unpacked_conformant_array_schema   

(*6.3*)       constant ::= ( sign)? ( unsigned_number | constant_identifier ) 
                       | character_string   

(*6.3*)       constant_definition ::= identifier '=' constant   

(*6.2.1*)     constant_definition_part ::= ( 'const' constant_definition ';' ( constant_definition ';')*)?   

(*6.3*)       constant_identifier ::= 'constant_ID'   (* identifier   *)

(*6.8.3.9*)   control_variable ::= entire_variable   

(*6.1.1*)     digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'   

(*6.1.5*)     digit_sequence ::= digit ( digit)*   

(*6.1.4*)     directive ::= 'ID'   

(*6.4.4*)     domain_type ::= type_identifier   

(*6.8.3.4*)   else_part ::= 'else' statement   

(*6.8.2.1*)   (* empty_statement ::= #  *)

(*6.5.2*)     entire_variable ::= variable_identifier   

(*6.4.2.3*)   enumerated_type ::= '(' identifier_list ')'   

(*6.7.1*)     expression ::= simple_expression ( relational_operator simple_expression)?   

(*6.6.3.7.1*) (*factor > bound_identifier   *)

(*6.7.1*)     factor (*>*) ::= variable_access | unsigned_constant | function_designator 
                     | set_constructor | '(' expression ')' | 'not' factor   

(*6.5.3.3*)   field_designator ::= record_variable '.' field_specifier | field_designator_identifier   

(*6.8.3.10*)  field_designator_identifier ::= identifier   

(*6.5.3.3*)   field_identifier ::= 'field_ID'   

(*6.4.3.3*)   field_list ::= ( ( fixed_part ( ';' variant_part)? | variant_part ) ( ';')?)?   

(*6.5.3.3*)   field_specifier ::= field_identifier   

(*6.4.3.5*)   file_type ::= 'file' 'of' component_type   

(*6.5.5*)     file_variable ::= variable_access   

(*6.8.3.9*)   final_value ::= expression   

(*6.4.3.3*)   fixed_part ::= record_section ( ';' record_section)*   

(*6.8.3.9*)   for_statement ::= 'for' control_variable ':=' initial_value ( 'to' | 'downto' ) final_value 
                              'do' statement   

(*6.6.3.1*)   formal_parameter_list ::= '(' formal_parameter_section ( ';' formal_parameter_section)* ')'   

(*6.6.3.1*)   formal_parameter_section (*>*) ::= value_parameter_specification 
                                       | variable_parameter_specification 
                                       | procedural_parameter_specification 
                                       | functional_parameter_specification   

(*6.6.3.7.1*) (*formal_parameter_section > conformant_array_parameter_specification   *)

(*6.1.5*)     fractional_part ::= digit_sequence   

(*6.6.2*)     function_block ::= block   

(*6.6.2*)     function_declaration ::= function_heading ';' directive 
                                   | function_identification ';' function_block 
                                   | function_heading ';' function_block   

(*6.7.3*)     function_designator ::= function_identifier ( actual_parameter_list)?   

(*6.6.2*)     function_heading ::= 'function' identifier ( formal_parameter_list)? ':' result_type   

(*6.6.2*)     function_identification ::= 'function' function_identifier   

(*6.6.2*)     function_identifier ::= 'function_ID'  (* identifier   *)

(*6.6.3.1*)   functional_parameter_specification ::= function_heading   

(*6.8.2.4*)   goto_statement ::= 'goto' label   

(*6.5.4*)     identified_variable ::= pointer_variable '^'    

(*6.1.3*)     identifier ::= 'ID'  (* letter ( letter | digit)*  *) 

(*6.4.2.3*)   identifier_list ::= identifier ( ',' identifier)*   

(*6.8.3.4*)   if_statement ::= 'if' Boolean_expression 'then' statement ( else_part)?   

(*6.5.3.2*)   index_expression ::= expression   

(*6.4.3.2*)   index_type ::= ordinal_type   

(*6.6.3.7.1*) index_type_specification ::= identifier '..' identifier ':' ordinal_type_identifier   

(*6.5.3.2*)   indexed_variable ::= array_variable '[' index_expression ( ',' index_expression)* ']'   

(*6.8.3.9*)   initial_value ::= expression   

(*6.1.6*)     label ::= digit_sequence   

(*6.2.1*)     label_declaration_part ::= ( 'label' label ( ',' label)* ';')?   

(*6.1.1*)     letter ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' 
                     | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' 
                     | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'   

(*6.7.1*)     member_designator ::= expression ( '..' expression)?   

(*6.7.2.1*)   multiplying_operator ::= '*' | '/' | 'div' | 'mod' | 'and'   

(*6.4.2.1*)   new_ordinal_type ::= enumerated_type | subrange_type   

(*6.4.4*)     new_pointer_type ::= '^'  domain_type   

(*6.4.3.1*)   new_structured_type ::= ( 'packed')? unpacked_structured_type   

(*6.4.1*)     new_type ::= new_ordinal_type | new_structured_type | new_pointer_type   

(*6.4.2.1*)   ordinal_type ::= new_ordinal_type | ordinal_type_identifier   

(*6.4.2.1*)   ordinal_type_identifier ::= type_identifier   

(*6.6.3.7.1*) packed_conformant_array_schema ::= 'packed' 'array' '[' index_type_specification ']' 
                                               'of' type_identifier   

(*6.4.4*)     pointer_type ::= new_pointer_type | pointer_type_identifier   

(*6.4.1*)     pointer_type_identifier ::= type_identifier   

(*6.5.4*)     pointer_variable ::= variable_access   

(*6.6.3.1*)   procedural_parameter_specification ::= procedure_heading   

(*6.2.1*)     procedure_and_function_declaration_part ::= ( ( procedure_declaration 
                                                      | function_declaration ) ';')*   

(*6.6.1*)     procedure_block ::= block   

(*6.6.1*)     procedure_declaration ::= procedure_heading ';' directive 
                                    | procedure_identification ';' procedure_block 
                                    | procedure_heading ';' procedure_block   

(*6.6.1*)     procedure_heading ::= 'procedure' identifier ( formal_parameter_list)?   

(*6.6.1*)     procedure_identification ::= 'procedure' procedure_identifier   

(*6.6.1*)     procedure_identifier ::= 'procedure_ID' | 'write' | 'writeln' | 'read' | 'readln'  (* identifier   *)

(*6.8.2.3*)   procedure_statement ::= procedure_identifier ( ( actual_parameter_list)? 
                                  | read_parameter_list | readln_parameter_list 
                                  | write_parameter_list | writeln_parameter_list )   

(*6.10*)     // program ::= program_heading ';' program_block '.'   

(*6.10*)      program_block ::= block   

(*6.10*)      program_heading ::= 'program' identifier ( '(' program_parameter_list ')')?   

(*6.10*)      program_parameter_list ::= identifier_list   

(*6.9.1*)     read_parameter_list ::= '(' ( file_variable ',')? variable_access ( ',' variable_access)* ')'   

(*6.9.2*)     readln_parameter_list ::= ( '(' ( file_variable | variable_access ) 
                                      ( ',' variable_access)* ')')?   

(*6.4.2.1*)   real_type_identifier ::= type_identifier   

(*6.4.3.3*)   record_section ::= identifier_list ':' type_denoter   

(*6.4.3.3*)   record_type ::= 'record' field_list 'end'   

(*6.5.3.3*)   record_variable ::= variable_access   

(*6.8.3.10*)  record_variable_list ::= record_variable ( ',' record_variable)*   

(*6.7.2.1*)   relational_operator ::= '=' | '<>' | '<' | '>' | '<=' | '>=' | 'in'   

(*6.8.3.7*)   repeat_statement ::= 'repeat' statement_sequence 'until' Boolean_expression   

(*6.8.3.6*)   repetitive_statement ::= repeat_statement | while_statement | for_statement   

(*6.6.2*)     result_type ::= simple_type_identifier | pointer_type_identifier   

(*6.1.5*)     scale_factor ::= ( sign)? digit_sequence   

(*6.7.1*)     set_constructor ::= '[' ( member_designator ( ',' member_designator)*)? ']'   

(*6.4.3.4*)   set_type ::= 'set' 'of' base_type   

(*6.1.5*)     sign ::= '+' | '-'        

(*6.1.5*)     signed_integer ::= ( sign)? unsigned_integer   

(*6.1.5*)     signed_number ::= signed_integer | signed_real   

(*6.1.5*)     signed_real ::= ( sign)? unsigned_real   

(*6.7.1*)     simple_expression ::= ( sign)? term ( adding_operator term)*   

(*6.8.2.1*)   simple_statement ::= (* empty_statement *) # | assignment_statement 
                               | procedure_statement | goto_statement   

(*6.4.2.1*)   simple_type ::= ordinal_type | real_type_identifier   

(*6.4.1*)     simple_type_identifier ::= type_identifier   

(*6.1.2*)     special_symbol ::= '+' | '-'      | '*' | '/' | '=' | '<' | '>' | '[' | ']' 
                             | '.' | ',' | ':' | ';' | '^'  | '(' | ')' 
                             | '<>' | '<=' | '>=' | ':=' | '..' | word_symbol   

(*6.8.1*)     statement ::= ( label ':')? ( simple_statement | structured_statement )   

(*6.2.1*)     statement_part ::= compound_statement   

(*6.8.3.1*)   statement_sequence ::= statement ( ';' statement)*   

(*6.1.7*)     (*string_character ::= one_of_a_set_of_implementation_defined_characters   *)

(*6.1.7*)     (* string_element ::= apostrophe_image | string_character   *)

(*6.8.3.1*)   structured_statement ::= compound_statement | conditional_statement 
                                   | repetitive_statement | with_statement   

(*6.4.3.1*)   structured_type ::= new_structured_type | structured_type_identifier   

(*6.4.1*)     structured_type_identifier ::= type_identifier   

(*6.4.2.4*)   subrange_type ::= constant '..' constant   

(*6.4.3.3*)   tag_field ::= identifier   

(*6.4.3.3*)   tag_type ::= ordinal_type_identifier   

(*6.7.1*)     term ::= factor ( multiplying_operator factor)*   

(*6.4.1*)     type_definition ::= identifier '=' type_denoter   

(*6.2.1*)     type_definition_part ::= ( 'type' type_definition ';' ( type_definition ';')*)?   

(*6.4.1*)     type_denoter ::= type_identifier | new_type   

(*6.4.1*)     type_identifier ::= 'type_ID'   (*identifier  *) 

(*6.6.3.7.1*) unpacked_conformant_array_schema ::= 
                   'array' '[' index_type_specification ( ';' index_type_specification)* ']' 
                   'of' ( type_identifier | conformant_array_schema )   

(*6.4.3.1*)   unpacked_structured_type ::= array_type | record_type | set_type | file_type   

(*6.7.1*)     unsigned_constant ::= unsigned_number | character_string | constant_identifier | 'nil'   

(*6.1.5*)     unsigned_integer ::= 'INTEGER' (* digit_sequence *)   

(*6.1.5*)     unsigned_number ::= unsigned_integer | unsigned_real   

(*6.1.5*)     unsigned_real ::= 'REAL'   (* digit_sequence '.' fractional_part ( 'e' scale_factor)? 
                            | digit_sequence 'e' scale_factor   *)

(*6.6.3.7.1*) value_conformant_array_specification ::= identifier_list ':' conformant_array_schema   

(*6.6.3.1*)   value_parameter_specification ::= identifier_list ':' type_identifier   

(*6.5.1*)     variable_access ::= entire_variable | component_variable | identified_variable 
                              | buffer_variable   

(*6.6.3.7.1*) variable_conformant_array_specification ::= 'var' identifier_list ':' conformant_array_schema   

(*6.5.1*)     variable_declaration ::= identifier_list ':' type_denoter   

(*6.2.1*)     variable_declaration_part ::= ( 'var' variable_declaration ';' ( variable_declaration ';')*)?   

(*6.5.2*)     variable_identifier ::= 'variable_ID'   (* identifier   *)

(*6.6.3.1*)   variable_parameter_specification ::= 'var' identifier_list ':' type_identifier   

(*6.4.3.3*)   variant ::= case_constant_list ':' '(' field_list ')'   

(*6.4.3.3*)   variant_part ::= 'case' variant_selector 'of' variant ( ';' variant)*   

(*6.4.3.3*)   variant_selector ::= ( tag_field ':')? tag_type   

(*6.8.3.8*)   while_statement ::= 'while' Boolean_expression 'do' statement   

(*6.8.3.10*)  with_statement ::= 'with' record_variable_list 'do' statement   

(*6.1.2*)     word_symbol ::= 'and' | 'array' | 'begin' | 'case' | 'const' | 'div' 
                          | 'do' | 'downto' | 'else' | 'end' | 'file' | 'for' 
                          | 'function' | 'goto' | 'if' | 'in' | 'label' | 'mod' 
                          | 'nil' | 'not' | 'of' | 'or' | 'packed' | 'procedure' 
                          | 'program' | 'record' | 'repeat' | 'set' | 'then' 
                          | 'to' | 'type' | 'until' | 'var' | 'while' | 'with'   

(*6.9.3*)     write_parameter ::= expression ( ':' expression ( ':' expression)?)?   

(*6.9.3*)     write_parameter_list ::= '(' ( file_variable ',')? write_parameter 
                                     ( ',' write_parameter)* ')'   

(*6.9.4*)     writeln_parameter_list ::= ( '(' ( file_variable | write_parameter ) 
                                       ( ',' write_parameter)* ')')?   
 