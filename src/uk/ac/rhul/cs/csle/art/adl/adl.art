(* adl - a dynamic language (or maybe Adrian's dynamic language) *)
!whitespace(&SIMPLE_WHITESPACE,&COMMENT_BLOCK_C,&COMMENT_LINE_C)
adl      ::= #^ | ';'^ | seq^^     // A script may be empty, or just a semicolon or a sequence
seq      ::= apply^^ | apply ';'^ seq  // void-left operator
apply    ::= typed | typed apply^      // 'space' operator (juxtaposition) apply
typed    ::= def^^ | def '::' ID
def      ::= slice^^ | const^^ | assign^^
const    ::= lhsLst '='^ def
assign   ::= lhsLst ':='^ def
lhsLst   ::= lhsEl^ | lhsEl^ ','^ lhsLst^
lhsEl    ::= ID^^ | ID^ '::'^ ID 
slice    ::= list^^ | list '#'^ or | list '#'^ or '..'^ or | list '#'^ or '..'^ or '..'^ or
list     ::= pair^^ | pair ','^ listTail^
listTail ::= pair  | pair ','^ listTail^
pair     ::= or^^ | or ':'^ or
or       ::= xor^^ |  or '|'^ xor 
xor      ::= and^^ | xor '^'^ and 
and      ::= eqs^^ | eqs '&'^ and
eqs      ::= rels^^ | eq^^ | ne^^
  eq     ::= rels '=='^ rels 
  ne     ::= rels '!='^ rels 
rels     ::= cat^^ | ge^^ | gt^^ | le^^ | lt^^
  ge     ::= cat '>='^ cat 
  gt     ::= cat '>'^ cat 
  le     ::= cat '<='^ cat 
  lt     ::= cat '<'^ cat
cat      ::=  shs^^  | cat '::'^ shs
shs      ::=  adds^^ | lsh^^ | rsh^^ | rol^^ | ror^^ | ash^^
  lsh    ::= shs '<<'^ adds 
  rsh    ::= shs '>>'^ adds 
  rol    ::= shs '<<|'^ adds 
  ror    ::= shs '>>|'^ adds
  ash    ::= shs '>>>'^ adds 
adds     ::= muls^^ | add^^ | sub^^
  add    ::= adds '+'^ muls 
  sub    ::= adds '-'^ muls 
muls     ::=  exp^^ | mul^^ | div^^ | mod^^
  mul    ::= muls '*'^ exp  
  div    ::= muls '/'^ exp 
  mod    ::= muls '%'^ exp
exp      ::= base^^ | base '**'^ exp
base     ::= pos^^ | neg^^ | not^^ | lambda^^ | blist^^ | mtlist^^
           | __bool^^ | __int32^^ | __real64^^ | __char^^ | __string^^ | use^^ | '_'^^    
           | __done | __empty | break | continue | return | yield | match | matchrep
           | '('^ seq^^ ')'^ | scope^^
pos      ::= '+'^ base
neg      ::= '-'^ base
not      ::= '!'^ base
lambda   ::= 'fn'^ lhsLst scope^ | 'fn'^ '('^ lhsLst ')'^ scope^
blist    ::= '['^ seq ']'^
mtlist   ::= '['^ ']'^
use      ::= ID^
__done   ::= 'done'^
__empty  ::= 'empty'^
break    ::= 'break'^
continue ::= 'continue'^
return   ::= 'return'^
yield    ::= 'yield'
match    ::= '('^ list '?'^ list skip ')'^ | '('^ list '?'^ list '~' list ')'^ 
matchrep ::= '('^ list '@'^ list skip ')'^ | '('^ list '@'^ list '~' list ')'^ 
skip     ::= #^
scope    ::= '{'^ seq '}'^ 

// Lexical elements below this line - replace with paraterminals when MGLL working
ID       ::= &ID
__bool   ::= 'True'^^ | 'False'^^
__int32  ::= &INTEGER
__real64 ::= &REAL
__char   ::= &STRING_SQ
__string ::= &STRING_DQ
