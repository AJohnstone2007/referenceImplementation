(* adl - a dynamic language (or maybe Adrian's dynamic language) *)
!whitespace(&SIMPLE_WHITESPACE,&COMMENT_BLOCK_C,&COMMENT_LINE_C)
adl      ::= #^ | seq^^ | ';' | seq ';'                // top level expression may be empty or a seq followed by optional semicolon
seq      ::= apply^^ | apply ';'^ seq                  // and-also (void-left) operator
apply    ::= flow | flow apply^                        // 'space' operator (juxtaposition) apply
flow     ::= def^^ | match^^ | matchr^^                // non-linear flow control
  match  ::= def '?'^ flow skip | def '?'^ flow '~'^ def // pattern matching
  matchr ::= def '@'^ flow skip | def '@'^ flow '~'^ def // pattern matching and repeat
  skip   ::= #^                                        // do-nothing
def      ::= slice^^ | const^^ | assign^^              // assign and constant definition
  const  ::= lhslst '='^ def
  assign ::= lhslst ':='^ def
  lhslst ::= lhselm^ | lhselm^ ','^ lhselm^            // restricted syntax for LHS of definitions and function parameters
  lhselm ::= ID^^ | ID^^ '::'^ or                      // pair interpreted as paramater-name(default value) 
slice    ::= list^^                                    // extract a sub list
           | list '#'^ or | list '#'^ or '..'^ or | list '#'^ or '..'^ or '..'^ or
list     ::= pair^^ | pair ','^ listtl^
  listtl ::= pair  | pair ','^ listtl^
pair     ::= or^^ | or '::'^ or                        // sugar for list of exactly two elements
or       ::= xor^^ |  or '|'^ xor 
xor      ::= and^^ | xor '^'^ and 
and      ::= eqs^^ | eqs '&'^ and
eqs      ::= rels^^ | eq^^ | ne^^
  eq     ::= rels '=='^ rels 
  ne     ::= rels '!='^ rels 
rels     ::= cat^^ | ge^^ | gt^^ | le^^ | lt^^
  ge     ::= cat '>='^ cat 
  gt     ::= cat '>'^ cat 
  le     ::= cat '<='^ cat 
  lt     ::= cat '<'^ cat
cat      ::= shs^^  | cat ':'^ shs
shs      ::= adds^^ | lsh^^ | rsh^^ | rol^^ | ror^^ | ash^^
  lsh    ::= shs '<<'^ adds 
  rsh    ::= shs '>>'^ adds 
  rol    ::= shs '<<|'^ adds 
  ror    ::= shs '>>|'^ adds
  ash    ::= shs '>>>'^ adds 
adds     ::= muls^^ | add^^ | sub^^
  add    ::= adds '+'^ muls 
  sub    ::= adds '-'^ muls 
muls     ::= exp^^ | mul^^ | div^^ | mod^^
  mul    ::= muls '*'^ exp  
  div    ::= muls '/'^ exp 
  mod    ::= muls '%'^ exp
exp      ::= cast^^ | cast '**'^ exp
cast     ::= base^^ | base '$'^ ID^                    // attempt to cast a value to another type, throwing an exeption if unavailable
base     ::= pos^^ | neg^^ | not^^ | lambda^^ | system^^ | blist^^ | mtlist^^ | use^^ | '('^ seq^^ ')'^ | scope^^  
           | __bool^^ | __int32^^ | __real64^^ | __char^^ | __string^^ | __done^^ | __empty^^ | any | break^^ | continue^^ | return^^ | yield^^
pos      ::= '!+'^ base
neg      ::= '!-'^ base
not      ::= '!'^ base
lambda   ::= '\'^ lhslst scope^ | '\'^ '('^ lhslst ')'^ scope^
system   ::= '$$$'^
blist    ::= '['^ seq ']'^                               // fully bracketed list, allowing single element lists
mtlist   ::= '['^ ']'^                                   // empty list (since empty seq is not allowed)
use      ::= ID^
any      ::= '_'^  
__done   ::= 'done'^
__empty  ::= 'empty'^
break    ::= 'break'^
continue ::= 'continue'^
return   ::= 'return'^
yield    ::= 'yield'^
scope    ::= '{'^ seq '}'^ 

// Lexical elements below this line - replace with paraterminals when MGLL working
ID       ::= &ID
__bool   ::= 'true'^^ | 'false'^^
__int32  ::= &INTEGER
__real64 ::= &REAL
__char   ::= &STRING_SQ
__string ::= &STRING_DQ
