(* adl - a dynamic language (or maybe Adrian's dynamic language) *)
!whitespace(&SIMPLE_WHITESPACE,&COMMENT_BLOCK_C,&COMMENT_LINE_C)
adl    ::= #^ | sep^ | seq^^ 
seq    ::= def^^ | seq sep^ def
sep    ::= #^ | ';'^ sep^ 
def    ::= slice^^ | const^^ | assign^^
const  ::= lhsLst^ '='^ def
assign ::= lhsLst^ ':='^ def
lhsLst ::= lhs | '('^ lhs ')'^
lhs    ::= &ID | &ID ','^ lhs  
slice  ::= pair^^ | pair '#'^ slicer^
slicer ::= or | sel '..'^ sel | sel '..'^ sel '..'^ sel
pair   ::= list^^ | list ':'^ list
pairs  ::= pair^^ | pair pairs
list   ::= or^^  | or ','^ list 
or     ::= xor^^ |  or '|'^ xor 
xor    ::= and^^ | xor '^'^ and 
and    ::= eqs^^ | eqs '&'^ and
eqs    ::= rels^^ | eq^^ | ne^^
eq     ::= rels '=='^ rels 
ne     ::= rels '!='^ rels 
rels   ::= cat^^ | ge^^ | gt^^ | le^^ | lt^^
ge     ::= cat '>='^ cat 
gt     ::= cat '>'^ cat 
le     ::= cat '<='^ cat 
lt     ::= cat '<'^ cat
cat    ::=  shs^^  | cat '::'^ shs
shs    ::=  adds^^ | lsh^^ | rsh^^ | rol^^ | ror^^ | ash^^
lsh    ::= shs '<<'^ adds 
rsh    ::= shs '>>'^ adds 
rol    ::= shs '<<|'^ adds 
ror    ::= shs '>>|'^ adds
ash    ::= shs '>>>'^ adds 
adds   ::= muls^^ | add^^ | sub^^
add    ::= adds '+'^ muls 
sub    ::= adds '-'^ muls 
muls   ::=  exp^^ | mul^^ | div^^ | mod^^
mul    ::= muls '*'^ exp  
div    ::= muls '/'^ exp 
mod    ::= muls '%'^ exp
exp    ::= base^^ | base '**'^ exp
base   ::= pos^^ | neg^^ | not^^ | lambda^^
         | __bool^^ | __int32^^ | __real64^^ | __char^^ | __string^^ | use^^ | '_'^^  
         | __done | __empty | break | continue | return | yield | sel | iter
         | '('^ seq^^ ')'^ | scope^^
pos    ::= '!+'^ base
neg    ::= '!-'^ base
not    ::= '!'^ base
lambda ::= 'fn'^ parLst^ scope
parLst ::= par | '('^ par ')'^
par    ::= &ID skip | &ID skip ','^ par | &ID ':'^ or | &ID ':'^ or ','^ par 
use    ::= ID^
__done ::= 'done'^
__empty ::= 'empty'^
break  ::= 'break'^
continue ::= 'continue'^
return ::= 'return'^
yield  ::= 'yield'
sel    ::= '('^ list '?'^ pairs skip ')'^ | '('^ list '?'^ pairs '~' list ')'^ 
iter   ::= '('^ list '@'^ pairs skip ')'^ | '('^ list '@'^ pairs '~' list ')'^ 
skip   ::= #^
scope  ::= '{'^ seq '}'^ 

// Lexical elements below this line - replace with paraterminals when MGLL working
ID       ::= &ID 
__bool   ::= 'True'^^ | 'False'^^
__int32  ::= &INTEGER
__real64 ::= &REAL
__char   ::= &STRING_SQ
__string ::= &STRING_DQ
