/*
*
* An abstract class which defines support methods for GLL parsers
* generated by the ART tool.
*
* (c) Adrian Johnstone 2013
*/
package uk.ac.rhul.cs.csle.art.v3.alg.gll.support;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import uk.ac.rhul.cs.csle.art.core.ARTUncheckedException;
import uk.ac.rhul.cs.csle.art.term.ITerms;
import uk.ac.rhul.cs.csle.art.term.ITermsLowLevelAPI;
import uk.ac.rhul.cs.csle.art.util.histogram.ARTHistogram;
import uk.ac.rhul.cs.csle.art.util.text.ARTText;
import uk.ac.rhul.cs.csle.art.v3.alg.ARTParserBase;
import uk.ac.rhul.cs.csle.art.v3.lex.ARTLexerV3;
import uk.ac.rhul.cs.csle.art.v3.lex.ARTTWEPairSet;
import uk.ac.rhul.cs.csle.art.v3.manager.grammar.ARTGrammar;

public abstract class ARTGLLParserBase extends ARTParserBase {
  protected static boolean ARTTRACETWE = false;
  public ARTGLLRDT artRDT = null;
  public boolean artSPPFHasCycles = false;

  protected int artWhitespaceEOSPrefixLength; // The amount of whitespace at the end of the file for acceptance handling

  // Pairs
  public int artInputPairBuffer[]; // Holds all unique input pairs; index into this buffer of a pair (a,i) is its handle in descriptors
  public int artInputPairIndex[][]; // Index of input pairs: contents of location (a, i) is the address of (a,i) in inputPair Buffer, a.k.a the pair's
                                    // handle
  public int artInputFirstPairAtLeftExtent[]; // For a given leftExtent, this holds the handle of the first pair in the inputPairBuffer. This is used as a
  public int artInputSuccessorIndex[][]; // Index of successor handles: contents of location (a, i) is the addess of first successor of (a,i)
  public int artCurrentInputPairReference; // handle for current input pair; index of this pair into inputPairBuffer
  public int artCurrentInputPairIndex; // Index into pair buffer used by parsers
  protected int artTokenExtent; // to be set to one plus the highest paraterminal's token number

  public ARTGLLParserBase(ARTGrammar artGrammar, ARTLexerV3 artLexer) {
    super(artGrammar, artLexer);
  }

  /**
   * Getters, setters and iterators
   */
  abstract public int artSPPFNodeLabel(int element);

  abstract public int artSPPFNodeLeftExtent(int element);

  abstract public int artSPPFNodeRightExtent(int element);

  abstract public int artSPPFNodePackedNodeList(int element);

  // Symbol nodes may be visited or selected
  abstract public boolean artSPPFNodeVisited(int element);

  abstract public void artSPPFNodeResetVisited(int element);

  abstract public void artSPPFNodeSetVisited(int element);

  public void artSPPFResetVisitedFlags() {
    for (int element = artSPPFNodeFirst(); element != 0; element = artSPPFNodeNext())
      artSPPFNodeResetVisited(element);
  }

  abstract public boolean artSPPFNodeSelected(int element);

  abstract public void artSPPFNodeResetSelected(int element);

  abstract public void artSPPFNodeSetSelected(int element);

  abstract public int artSPPFPackedNodeParent(int element);

  abstract public int artSPPFPackedNodeLabel(int element);

  abstract public int artSPPFPackedNodePivot(int element);

  abstract public int artSPPFPackedNodeLeftChildLabel(int element);

  abstract public int artSPPFPackedNodeRightChildLabel(int element);

  abstract public int artSPPFPackedNodePackedNodeList(int element);

  // Packed nodes may be suppressed or selected
  abstract public boolean artSPPFPackedNodeSuppressed(int element);

  abstract public void artSPPFPackedNodeResetSuppressed(int element);

  abstract public void artSPPFPackedNodeSetSuppressed(int element);

  abstract public boolean artSPPFPackedNodeSelected(int element);

  abstract public void artSPPFPackedNodeResetSelected(int element);

  abstract public void artSPPFPackedNodeSetSelected(int element);

  /*
   * Iterate over all SPPF nodes independent of linking
   */
  abstract public int artSPPFNodeFirst();

  abstract public int artSPPFNodeNext();

  abstract public int artSPPFNodeArity(int element);

  abstract public int artGSSNodeLabel(int element);

  abstract public int artGSSNodeLevel(int element);

  abstract public int artGSSNodeEdgeList(int element);

  abstract public int artGSSEdgeSPPFNode(int element);

  abstract public int artGSSEdgeSource(int element);

  abstract public int artGSSEdgeDestination(int element);

  abstract public int artGSSEdgeEdgeList(int element);

  /*
   * Iterate over all GSS nodes independent of linking
   */
  abstract public int artGSSNodeFirst();

  abstract public int artGSSNodeNext();

  /* Iterate over all GSS edges independent of linking */
  abstract public int artGSSEdgeFirst();

  abstract public int artGSSEdgeNext();

  /**
   * Internal methods
   */
  protected abstract int artFindRightmostTerminalSPPFNode();

  protected void artReportParseError(int rightMostSPPFNode) {
    int label = artSPPFNodeLabel(rightMostSPPFNode);
    if (artLexer.artInputLength <= 1)
      System.out.println("Parser error: unexpected empty string");
    else
      System.out.println(ARTText.echo("Parser error: found unexpected token after " + artLabelInternalStrings[label], artSPPFNodeRightExtent(rightMostSPPFNode),
          artLexer.artInputString));
  }

  /**
   * Public lexical access
   */
  public int artLabelEOS() {
    return ARTL_EOS;
  }

  public int artLabelEpsilon() {
    return ARTL_EPSILON;
  }

  public int artLabelAnnotation() {
    return ARTL_ANNOTATION;
  }

  public int artLabelDummy() {
    return ARTL_DUMMY;
  }

  public String artLabelToString(int label) {
    return artLabelStrings[label];
  }

  /**
   * Input string manipulation
   *
   * @
   */
  protected String artLexeme(int leftExtent, int rightExtent) {
    return artlexeme(leftExtent, rightExtent, 0, 0);
  }

  protected String artlexeme(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) {
    // May 2016 modified to strip whitespace from front of lexeme
    artLexer.artInputIndex = leftExtent;
    artLexer.artLexicalisePreparseWhitespace();

    // System.out.println("artlexeme " + artcharacterStringInputIndex + ":" + rightExtent + " '"
    // + artcharacterStringInput.substring(artcharacterStringInputIndex, rightExtent) + "'");
    return artLexer.artInputString.substring(artLexer.artInputIndex + leftDelimiterWidth, rightExtent - rightDelimiterWidth);
  }

  protected String artLexemeAsID(int leftExtent, int rightExtent) {
    return artLexeme(leftExtent, rightExtent);
  }

  protected int artLexemeAsSML_Integer(int leftExtent, int rightExtent) throws NumberFormatException {
    String s = artLexeme(leftExtent, rightExtent).replace('~', '-');
    int start = 0;
    int sign = 1;
    if (s.charAt(start) == '-') {
      sign = -1;
      start++;
    }
    int radix = 10;
    if (s.charAt(start) == '0' && s.charAt(start + 1) == 'x') {
      radix = 16;
      start += 2;
    }

    return sign * Integer.parseInt(s.substring(start), radix);
  }

  protected int artLexemeAsSML_Word(int leftExtent, int rightExtent) throws NumberFormatException {
    String s = artLexeme(leftExtent, rightExtent);
    int start = 2;
    int radix = 10;
    if (s.charAt(start) == 'x') {
      radix = 16;
      start++;
    }

    return Integer.parseInt(s.substring(start), radix);
  }

  protected double artLexemeAsSML_Real(int leftExtent, int rightExtent) throws NumberFormatException {
    return Double.parseDouble(artLexeme(leftExtent, rightExtent).replace('~', '-'));
  }

  protected String artLexemeAsSML_String(int leftExtent, int rightExtent) {
    return artLexemeAsString(leftExtent, rightExtent, 1, 1);
  }

  protected Character artLexemeAsSML_Char(int leftExtent, int rightExtent) {
    return artLexemeAsString(leftExtent, rightExtent, 2, 1).charAt(0);
  }

  protected int artLexemeAsInteger(int leftExtent, int rightExtent) throws NumberFormatException {
    return Integer.parseInt(artLexeme(leftExtent, rightExtent));
  }

  protected double artLexemeAsReal(int leftExtent, int rightExtent) throws NumberFormatException {
    return Double.parseDouble(artLexeme(leftExtent, rightExtent));
  }

  protected String artLexemeAsRawString(int leftExtent, int rightExtent) {
    return artLexemeAsRawString(leftExtent, rightExtent, 1, 1);
  }

  protected String artLexemeAsRawString(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) {
    return artlexeme(leftExtent, rightExtent, leftDelimiterWidth, rightDelimiterWidth);
  }

  protected String artLexemeAsString(int leftExtent, int rightExtent) {
    return artLexemeAsString(leftExtent, rightExtent, 1, 1);
  }

  // This function is used to convert string like lexemes into ASCII strings with escape sequence replacement
  // We are passed the leftExtent and the rightExtent,
  protected String artLexemeAsString(int leftExtent, int rightExtent, int leftDelimiterWidth, int rightDelimiterWidth) {
    // System.err.printf("%nlexemeAsString received %d to %d |%s| with delimiter widths L=%d, R=%d%n", leftExtent, rightExtent,
    // artcharacterStringInput.substring(leftExtent, rightExtent), leftDelimiterWidth, rightDelimiterWidth);
    artLexer.artInputIndex = leftExtent;
    artLexer.artLexicalisePreparseWhitespace();

    int left = artLexer.artInputIndex + leftDelimiterWidth;
    int right;
    int count = 0;
    for (right = left; right < rightExtent - rightDelimiterWidth;) {
      count++;
      if (artLexer.artInputString.charAt(right) == '\\') {
        if (Character.isDigit(artLexer.artInputString.charAt(right + 1)))
          right += 4;
        else
          right += 2;
      } else
        right++;
    }

    // System.err.printf("%nlexemeAsString string length is %d%n", count);
    char ret[] = new char[count];
    for (int i = 0; i < count; i++)
      ret[i] = ' ';
    int retI = 0;

    for (right = left; right < rightExtent - rightDelimiterWidth;) {
      if (artLexer.artInputString.charAt(right) == '\\') {
        if (artLexer.artInputString.charAt(right + 1) == 'u') {
          int value = Integer.parseInt(artLexer.artInputString.substring(right + 2, right + 6), 16);
          ret[retI++] = (char) value;
          right += 6;
        } else {
          switch (artLexer.artInputString.charAt(right + 1)) {
          case 'b':
            ret[retI++] = '\b';
            break;
          case 'n':
            ret[retI++] = '\n';
            break;
          case 'r':
            ret[retI++] = '\r';
            break;
          case 't':
            ret[retI++] = '\t';
            break;
          case 'f':
            ret[retI++] = '\f';
            break;
          default:
            ret[retI++] = artLexer.artInputString.charAt(right + 1);
          }
          right += 2;
        }
      } else
        ret[retI++] = artLexer.artInputString.charAt(right++);
    }

    return new String(ret);

  }

  public String[] getArtLabelInternalStrings() {
    return artLabelInternalStrings;
  }

  public void setArtLabelInternalStrings(String[] artLabelInternalStrings) {
    this.artLabelInternalStrings = artLabelInternalStrings;
  }

  public long getArteSOSInterpretCompleteTime() {
    return arteSOSInterpretCompleteTime;
  }

  public void setArteSOSInterpretCompleteTime(long arteSOSInterpretCompleteTime) {
    this.arteSOSInterpretCompleteTime = arteSOSInterpretCompleteTime;
  }

  /*
   * Parser global variables
   */
  protected int artRootSPPFNode;
  protected int artDummySPPFNode;
  protected int artRootGSSNode;

  protected int artPoppingDescriptorsToBeProcessed;
  protected int artNonpoppingDescriptorsToBeProcessed;
  protected int artPoppingDescriptorsToBeProcessedTail;
  protected int artNonpoppingDescriptorsToBeProcessedTail;
  protected int artCurrentDescriptor;
  protected int artCurrentRestartLabel;
  protected int artCurrentSPPFNode;
  protected int artCurrentSPPFRightChildNode;
  protected int artCurrentGSSNode;
  protected int artTemporarySPPFNode;

  protected int[] artFolds;
  protected int[] artGathers;
  protected int[] artpL;
  protected int[] artaL;
  protected int[] artcolonL;
  // protected int[] artsemiColonL;
  protected boolean[] artfiRL;
  protected boolean[] artfiPCL;
  protected boolean[] arteoOPL;
  protected boolean[] arteoRL;
  protected boolean[] arteoR_pL;
  protected boolean[] artPopD;
  protected boolean[] artIsLexical;

  /**
   * Getters
   */
  public int artSPPFRoot() {
    return artRootSPPFNode;
  }

  public int artSPPFPackedNodeLeftChild(int element) {
    int leftChildLabel = artSPPFPackedNodeLeftChildLabel(element);
    if (leftChildLabel == ARTL_DUMMY)
      return 0;
    else
      return artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(element)), artSPPFPackedNodePivot(element));
  }

  public int artSPPFPackedNodeRightChild(int element) {
    return artLookupSPPF(artSPPFPackedNodeRightChildLabel(element), artSPPFPackedNodePivot(element), artSPPFNodeRightExtent(artSPPFPackedNodeParent(element)));
  }

  public int artGSSRoot() {
    return artRootGSSNode;
  }

  /**
   * GLL support functions
   */
  abstract protected int artLookupSPPF(int label, int leftExtent, int rightExtent);

  abstract protected int artFindSPPFInitial(int label, int leftExtent, int rightExtent);

  abstract protected int artFindSPPFEpsilon(int currentTokenIndex);

  abstract protected int artFindSPPFTerminal(int label, int currentTokenIndex);

  abstract protected int artFindSPPFTerminal(int label, int currentTokenIndex, int tokenRightExtent); // For MGLL version

  abstract protected int artFindSPPF(int label, int leftChild, int rightChild);

  abstract protected int artFindSPPFClosure(int parentLabel, int childLabel, int currentTokenIndex);

  abstract protected int artFindSPPFBaseNode(int parentLabel, int childLabel, int currentTokenIndex);

  abstract protected int artFindGSS(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPop(int stackTop, int currentTokenIndex, int currentsppfNode);

  abstract protected void artFindDescriptor(int restartLabel, int gssNode, int currentTokenIndex, int sppfNode);

  abstract protected boolean artTestRepeat(int regexpLabel, int stackTop, int currentTokenIndex, int derivationNode);

  // MGLL variants
  abstract protected int artFindGSSMGLL(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPopMGLL(int stackTop, int currentTokenIndex, int currentsppfNode);

  // Clustered variants
  abstract protected int artFindGSSClusteredInitial(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected int artFindGSSClustered(int stackTopLabel, int stackTop, int currentToken, int currentsppfNode);

  abstract protected void artPopClustered(int nonTerminal, int k, int currentTokenIndex, int currentsppfNode);

  // Note this is esentially just an un-rename - it is here as a place holder in case we need to handle descriptors differently
  protected void artFindDescriptorClustered(int restartLabel, int gssNode, int currentTokenIndex, int sppfNode) {
    artFindDescriptor(restartLabel, gssNode, currentTokenIndex, sppfNode);
  };

  abstract protected void artCheckAcceptance();

  abstract boolean artNoDescriptors();

  abstract void artUnloadDescriptor();

  abstract void artUnloadDescriptorMGLL();

  abstract void artLoadDescriptorInitialMGLL();

  /**
   * TWE set collection
   */

  public ARTLexerV3 tweSet;

  void artCollectTWERec(int element, boolean postUseTerminals) {
    // artText.printf("artCollectTWERec() at node %s%n", artRenderSPPFNodeTitle(element));

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    if (/*
         * (artNonterminalsDeclaredAsTerminals != null && artNonterminalsDeclaredAsTerminals[artSPPFNodeLabel(element)]) ||
         */(postUseTerminals && artSPPFNodePackedNodeList(element) == 0)) { // declared terminal
      // or leaf
      // artText.println("located TWE set element " + artLabelStrings[artSPPFNodeLabel(element)] + ", " + artSPPFNodeLeftExtent(element) + ", "
      // + artSPPFNodeRightExtent(element));
      if (artSPPFNodeLeftExtent(element) < artSPPFNodeRightExtent(element)) // suppress epsilons
        tweSet.tweSetUpdateExactMakeLeftSet(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element));
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp) || sppfHidden.contains(tmp)) continue;

      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        artCollectTWERec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)), postUseTerminals);

      artCollectTWERec(artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
          postUseTerminals);
    }

  }

  /**
   * Analysis of ambiguity
   */
  public int ambiguitySymbolIntermediateNodeCount;
  public int ambiguityPackedNodeCount;
  public Map<Integer, Set<Integer>> ambiguityRelation;
  public Set<Integer> allHiddenOrSuppressed;

  private void computeIsAmbiguousRec(int element) {
    // System.out.printf("isAmbiguousRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // System.out.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    int visiblePackedNodeCount = 0;

    for (int left = artSPPFNodePackedNodeList(element); left != 0; left = artSPPFPackedNodePackedNodeList(left)) {
      if (sppfHidden.contains(left) || artSPPFPackedNodeSuppressed(left)) continue;
      visiblePackedNodeCount++;
      for (int right = artSPPFPackedNodePackedNodeList(left); right != 0; right = artSPPFPackedNodePackedNodeList(right)) {
        if (sppfHidden.contains(right) || artSPPFPackedNodeSuppressed(right)) continue;
        // System.out.println("Visible count " + visiblePackedNodeCount + " Ambiguous elements " + left + " and " + right);
        updateAmbiguityRelation(artSPPFPackedNodeLabel(left), artSPPFPackedNodeLabel(right));
      }
    }

    // System.out.println("Final visibility count at node " + element + " is " + visiblePackedNodeCount);
    if (visiblePackedNodeCount == 0) {
      // System.out.println("!!! Error: all packed nodes suppressed or hidden under node " + element);
      allHiddenOrSuppressed.add(element);
    }

    if (visiblePackedNodeCount > 1) {
      ambiguityPackedNodeCount += visiblePackedNodeCount;
      ambiguitySymbolIntermediateNodeCount++;
    }

    // System.out.println("Ambiguous symbol/intermediate nodes: " + ambiguitySymbolIntermediateNodeCount + " Ambiguous packed nodes: " +
    // ambiguityPackedNodeCount);

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (sppfHidden.contains(tmp) || artSPPFPackedNodeSuppressed(tmp)) continue;
      int leftChild = artSPPFPackedNodeLeftChild(tmp);

      if (leftChild != 0) computeIsAmbiguousRec(leftChild);
      computeIsAmbiguousRec(artSPPFPackedNodeRightChild(tmp));
    }

  }

  private void updateAmbiguityRelation(int left, int right) {
    if (left > right) { // swap order to canonicalise relation
      int temp = left;
      left = right;
      right = temp;
    }
    if (ambiguityRelation.get(left) == null) ambiguityRelation.put(left, new TreeSet<Integer>());
    if (ambiguityRelation.get(right) == null) ambiguityRelation.put(right, new TreeSet<Integer>());

    ambiguityRelation.get(left).add(right);
  }

  @Override
  public boolean computeIsAmbiguous(String str) {
    artSPPFResetVisitedFlags();
    ambiguitySymbolIntermediateNodeCount = ambiguityPackedNodeCount = 0;
    ambiguityRelation = new TreeMap<>();
    allHiddenOrSuppressed = new TreeSet<>();
    computeIsAmbiguousRec(artSPPFRoot());
    artSPPFResetVisitedFlags();

    if (str != null) {
      System.out.println(str);
      if (ambiguitySymbolIntermediateNodeCount != 0) {
        System.out.println("** Ambiguity analysis: SPPF is ambiguous");
        System.out.println("** Ambiguous SPPF symbol/intermediate nodes: " + ambiguitySymbolIntermediateNodeCount);
        System.out.println("** Ambiguous SPPF packed nodes: " + ambiguityPackedNodeCount);
        for (int left : ambiguityRelation.keySet())
          for (int right : ambiguityRelation.get(left))
            System.out.println("** " + artLabelInternalStrings[left] + " -> " + artLabelInternalStrings[right]);
        return true;
      } else
        System.out.println("** Ambiguity analysis: SPPF is unambiguous");

      if (allHiddenOrSuppressed.size() != 0) for (Integer e : allHiddenOrSuppressed)
        System.out.println("** No remaining packed nodes under " + e + ": " + artLabelInternalStrings[artSPPFNodeLabel(e)]);
    }
    return ambiguitySymbolIntermediateNodeCount != 0;
  }

  public ARTHistogram artPackedFamilyArityHistogram;
  int edgeCount, nonterminalNodeCount, intermediateNodeCount, packedNodeCount, terminalNodeCount, epsilonNodeCount, ambiguousPackedNodeCount;

  void coreStatisticsRec(int element, int parent) {
    // artText.printf("summaryStatisticsRec() at node %s%n", artRenderSPPFNodeTitle(element));

    edgeCount++;

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE)
      intermediateNodeCount++;
    else if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_NONTERMINAL)
      nonterminalNodeCount++;
    else if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_EPSILON)
      epsilonNodeCount++;
    else
      terminalNodeCount++;

    long unsuppressedCount = 0, suppressedCount = 0;

    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE || artKindOfs[artSPPFNodeLabel(element)] == ARTK_NONTERMINAL) {
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
        if (!this.artSPPFPackedNodeSuppressed(tmp) && !sppfHidden.contains(tmp))
          unsuppressedCount++;
        else
          suppressedCount++;
      if (suppressedCount != 0) artPackedFamilyArityHistogram.update(unsuppressedCount);
      if (suppressedCount != 0 && unsuppressedCount == 0) System.out.println("Symbol/intermediate node " + artRenderSPPFNodeTitle(element)
          + " under packed node " + artRenderSPPFPackedNodeTitle(parent) + " has ALL packed nodes suppressed or hidden");

      if (unsuppressedCount > 1) {
        ambiguousPackedNodeCount += unsuppressedCount;
        System.out.println("Symbol/intermediate node " + artRenderSPPFNodeTitle(element) + " under packed node " + artRenderSPPFPackedNodeTitle(parent)
            + " has multiple visible unsuppressed pack nodes");
        for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
          if (!this.artSPPFPackedNodeSuppressed(tmp)) System.out.println(" " + artRenderSPPFPackedNodeTitle(tmp));
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp)) continue;

      edgeCount++;

      packedNodeCount++;

      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        coreStatisticsRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)), tmp);

      coreStatisticsRec(artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
          tmp);
    }
  }

  public void coreStatistics(String msg, PrintStream stream) {
    if (stream == null) stream = System.out;

    if (msg != null) stream.println(msg);
    artSPPFResetVisitedFlags();
    artPackedFamilyArityHistogram = new ARTHistogram();

    edgeCount = -1;
    nonterminalNodeCount = intermediateNodeCount = packedNodeCount = terminalNodeCount = epsilonNodeCount = ambiguousPackedNodeCount = 0;
    if (artSPPFRoot() != 0 && !isTimedOut) coreStatisticsRec(artSPPFRoot(), 0);
    artSPPFResetVisitedFlags();
    stream.print("Edge count:," + edgeCount + ",Node counts: nonterminal," + nonterminalNodeCount + ", intermediate," + intermediateNodeCount + ", packed,"
        + packedNodeCount + ", ambiguous packed," + ambiguousPackedNodeCount + ", terminal," + terminalNodeCount + ", epsilon," + epsilonNodeCount + ", total:,"
        + (nonterminalNodeCount + intermediateNodeCount + packedNodeCount + terminalNodeCount + epsilonNodeCount) + ",");
    if (stream == System.out) stream.println();
    stream.println("Packed node family arity histogram: " + artPackedFamilyArityHistogram.toString());

    if (artPackedFamilyArityHistogram.bucketValue(0) != 0) stream.println("** Warning: choosers have suppressed an entire packed node family");
  }

  int countSentencesAmbiguityCount;

  class SentenceTrieNode {
    int token;
    SentenceTrieNode sibling, child;

    public SentenceTrieNode(int token, SentenceTrieNode sibling) {
      this.token = token;
      this.sibling = sibling;
    }

    SentenceTrieNode findChild(int token) {
      for (SentenceTrieNode tmp = child; tmp.sibling != null; tmp = tmp.sibling)
        if (tmp.token == token) return tmp;

      child = new SentenceTrieNode(token, child);

      return child;
    }
  }

  void countSentencesRec(int element, SentenceTrieNode trieNode) {
    // artText.printf("countSentencesRec() at node %s%n", artRenderSPPFNodeTitle(element));
    SentenceTrieNode newTrieNode = trieNode;
    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    int unsuppressedPackedNodes = 0;

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp)) continue;
      unsuppressedPackedNodes++;

      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        countSentencesRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)), newTrieNode);

      countSentencesRec(artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))),
          newTrieNode);
    }

    if (unsuppressedPackedNodes > 1) countSentencesAmbiguityCount++;
  }

  public void SPPFCountSentences() {
    System.out.println("sppfCountSentences");
    countSentencesAmbiguityCount = 0;
    artSPPFResetVisitedFlags();
    if (artSPPFRoot() != 0) countSentencesRec(artSPPFRoot(), new SentenceTrieNode(0, null));
    artSPPFResetVisitedFlags();
    System.out.println("Whilst counting sentences, found " + countSentencesAmbiguityCount + " ambiguous nodes");
  }

  @Override
  public ARTLexerV3 artSPPFCollectTWESet(boolean postUseTerminals) {
    tweSet = new ARTLexerV3(artHigher, artLonger, artLexer.artInputString, artLexer.artInputLength, ARTL_EOS, /* artLabelInternalStrings */ artLabelStrings,
        artDirectives, artTokenExtent);

    // Normalise the TWE set by putting an empty set into each null position
    for (int i = 0; i < tweSet.tweSet.length; i++)
      if (tweSet.tweSet[i] == null) tweSet.tweSet[i] = new ARTTWEPairSet();

    tweSet.tweSetUpdateExactMakeLeftSet(0, tweSet.tweSet.length - 2, tweSet.tweSet.length - 1); // Jam in final EoS

    artSPPFResetVisitedFlags(); // probably redundant, but still
    if (artSPPFRoot() != 0) artCollectTWERec(artSPPFRoot(), postUseTerminals);
    artSPPFResetVisitedFlags(); // probably redundant, but still

    return tweSet;
  }

  private void artDisambiguateOrderedLongestRec(int element) {
    // artText.printf("artDisambiguatePriorityLongestMatchRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - returning");
      return;
    }

    artSPPFNodeSetVisited(element);

    int candidate = 0;
    int candidatePivot = -1;

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      // artText.printf("Test: iterated to pack node node %d%n", tmp);
      if (candidate == 0 || (artSPPFPackedNodeLabel(tmp) < artSPPFPackedNodeLabel(candidate))
          || ((artSPPFPackedNodeLabel(tmp) == artSPPFPackedNodeLabel(candidate)) && (artSPPFPackedNodePivot(tmp) > candidatePivot))) {
        // artText.printf("Updating candidate to pack node node %d%n", tmp);
        candidate = tmp;
        candidatePivot = artSPPFPackedNodePivot(tmp);
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      // artText.printf("Suppress: iterated pack node node %d%n", tmp);
      if (tmp != candidate) {
        // artText.printf("Suppressing pack node %d%n", tmp);
        artSPPFPackedNodeSetSuppressed(tmp);
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        artDisambiguateOrderedLongestRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)));

      artDisambiguateOrderedLongestRec(
          artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))));
    }
  }

  @Override
  public void artDisambiguateOrderedLongest() {
    // System.out.println("sppfOrderedLongest");
    if (artSPPFRoot() != 0) artDisambiguateOrderedLongestRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
  }

  /* Chooser application */
  private void artChooseRec(int element) {
    // artText.printf("ART ChooseRec() at node %d %s%n", element, getArtLabelInternalStrings()[artSPPFNodeLabel(element)]);

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    for (int outer = artSPPFNodePackedNodeList(element); outer != 0; outer = artSPPFPackedNodePackedNodeList(outer)) {
      if (sppfHidden.contains(outer)) continue;
      for (int inner = artSPPFPackedNodePackedNodeList(outer); inner != 0; inner = artSPPFPackedNodePackedNodeList(inner)) {
        if (sppfHidden.contains(inner)) continue;
        // artText.printf("SPPF ambiguity test on packed nodes %d %s %d %s%n", outer, getArtLabelInternalStrings()[artSPPFPackedNodeLabel(outer)], inner,
        // getArtLabelInternalStrings()[artSPPFPackedNodeLabel(inner)]);

        if (artDirectives.b("sppfShortest")) {
          if (artShorter[artSPPFPackedNodeLabel(outer)] != null && artShorter[artSPPFPackedNodeLabel(outer)].get(artSPPFPackedNodeLabel(inner))
              && artSPPFPackedNodePivot(outer) < artSPPFPackedNodePivot(inner)) {
            // artText.printf("sppfShorter suppresses pack node %d under symbol node %d%n", inner, element);
            artSPPFPackedNodeSetSuppressed(inner);
          }
          if (artShorter[artSPPFPackedNodeLabel(inner)] != null && artShorter[artSPPFPackedNodeLabel(inner)].get(artSPPFPackedNodeLabel(outer))
              && artSPPFPackedNodePivot(inner) < artSPPFPackedNodePivot(outer)) {
            // artText.printf("sppfShorter suppresses pack node %d under symbol node %d%n", outer, element);
            artSPPFPackedNodeSetSuppressed(outer);
          }
        }

        if (artDirectives.b("sppfLongest")) {
          if (artLonger[artSPPFPackedNodeLabel(outer)] != null && artLonger[artSPPFPackedNodeLabel(outer)].get(artSPPFPackedNodeLabel(inner))
              && (artSPPFPackedNodePivot(outer) > artSPPFPackedNodePivot(inner))) {
            // artText.printf("sppfLonger suppresses pack node %d under symbol node %d%n", inner, element);
            artSPPFPackedNodeSetSuppressed(inner);
          }
          if (artLonger[artSPPFPackedNodeLabel(inner)] != null && artLonger[artSPPFPackedNodeLabel(inner)].get(artSPPFPackedNodeLabel(outer))
              && (artSPPFPackedNodePivot(inner) > artSPPFPackedNodePivot(outer))) {
            // artText.printf("sppfLonger suppresses pack node %d under symbol node %d%n", outer, element);
            artSPPFPackedNodeSetSuppressed(outer);
          }
        }

        if (artDirectives.b("sppfPriority")) {
          if (artHigher[artSPPFPackedNodeLabel(outer)] != null && artHigher[artSPPFPackedNodeLabel(outer)].get(artSPPFPackedNodeLabel(inner))) {
            // artText.printf("sppfHigher suppresses pack node %d under symbol node %d%n", inner, element);
            artSPPFPackedNodeSetSuppressed(inner);
          }
          if (artHigher[artSPPFPackedNodeLabel(inner)] != null && artHigher[artSPPFPackedNodeLabel(inner)].get(artSPPFPackedNodeLabel(outer))) {
            // artText.printf("sppfHigher suppresses pack node %d under symbol node %d%n", outer, element);
            artSPPFPackedNodeSetSuppressed(outer);
          }
        }
      }
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      int leftChildLabel = artSPPFPackedNodeLeftChildLabel(tmp);

      if (leftChildLabel != ARTL_DUMMY)
        artChooseRec(artLookupSPPF(leftChildLabel, artSPPFNodeLeftExtent(artSPPFPackedNodeParent(tmp)), artSPPFPackedNodePivot(tmp)));

      artChooseRec(artLookupSPPF(artSPPFPackedNodeRightChildLabel(tmp), artSPPFPackedNodePivot(tmp), artSPPFNodeRightExtent(artSPPFPackedNodeParent(tmp))));
    }
  }

  @Override
  public void artChoose() {
    // -- Debug Print the relations
    // System.out.println("SPPF higher:");
    // for (int i = 0; i < artHigher.length; i++) {
    // if (artHigher[i] == null) continue;
    // for (int j = 0; j < artHigher[i].length(); j++)
    // if (artHigher[i].get(j)) System.out.println(getArtLabelInternalStrings()[i] + " > " + getArtLabelInternalStrings()[j]);
    // }

    // System.out.println("SPPF longer:");
    // for (int i = 0; i < artLonger.length; i++) {
    // if (artLonger[i] == null) continue;
    // for (int j = 0; j < artLonger[i].length(); j++)
    // if (artLonger[i] != null && artLonger[i].get(j)) System.out.println(getArtLabelInternalStrings()[i] + " >> " + getArtLabelInternalStrings()[j]);
    // }
    artSPPFResetVisitedFlags();
    if (artDirectives.b("sppfShortest")) System.out.println("sppfShortest");
    if (artDirectives.b("sppfLongest")) System.out.println("sppfLongest");
    if (artDirectives.b("sppfPriority")) System.out.println("sppfPriority");

    if (artSPPFRoot() != 0) artChooseRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
  }

  /*
   * Derivation selection and construction
   */
  // returns node label if an ^^ has been encountered or we are intermediate, otherwise zero
  private int artDerivationAsTermRec(int element, List<Integer> parentChildren, ITerms iTerms, int fold) {
    // artText.printf("ArtDerivationAsTermRec() at node %d %s with fold arg %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)], fold);
    if (artSPPFNodeVisited(element)) throw new ARTUncheckedException("ArtDerivationAsTermRec() found cycle in derivation");

    // 1. Decide whether to append our children onto our parent's children or whether we will eventually make a new DT node
    List<Integer> children;
    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE || fold != ARTFOLD_NONE)
      children = parentChildren; // otherwise inset children into parent's children
    else {
      children = new LinkedList<>();
      // artText.printf(" made new linked list at node %d%n", element);
    }

    // 2. Gather return values from left and right children
    artSPPFNodeSetVisited(element);

    int leftResult = 0, rightResult = 0;
    // Recursively process children using only the first non-suppressed packed node
    for (int pnElement = artSPPFNodePackedNodeList(element); pnElement != 0; pnElement = artSPPFPackedNodePackedNodeList(pnElement))
      if (!artSPPFPackedNodeSuppressed(pnElement)) {
        // artText.printf(" Using packed node %d labelled %d %s%n", pnElement, artSPPFPackedNodeLabel(pnElement),
        // artLabelInternalStrings[artSPPFPackedNodeLabel(pnElement)]);

        int leftChild = artSPPFPackedNodeLeftChild(pnElement);
        int rightChild = artSPPFPackedNodeRightChild(pnElement);
        int leftFold = artFolds[artSPPFPackedNodeLabel(pnElement) - 2];
        int rightFold = artFolds[artSPPFPackedNodeLabel(pnElement)];
        if (leftChild != 0) {
          // artText.println("Calling left child " + leftChild + " with fold element " + (artSPPFPackedNodeLabel(pnElement) - 2) + " which is "
          // + artFolds[artSPPFPackedNodeLabel(pnElement) - 2]);
          leftResult = artDerivationAsTermRec(leftChild, children, iTerms, leftFold);// Left fold previous
          // artText.printf("ArtDerivationAsTermRec() at node %d %s: left child result is %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
          // leftResult);
        }

        // artText.println("Calling right child " + rightChild + " with fold element " + artSPPFPackedNodeLabel(pnElement) + " which is "
        // + artFolds[artSPPFPackedNodeLabel(pnElement)]);

        rightResult = artDerivationAsTermRec(rightChild, children, iTerms, rightFold);
        // artText.printf("ArtDerivationAsTermRec() at node %d %s: right child result is %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
        // rightResult);

        break;
      }

    artSPPFNodeResetVisited(element); // Unset the visited flag on the way out to allow un-sharing

    // 3. Compute unified result of children - we want the rightmost non-zero result
    int childResult = rightResult != 0 ? rightResult : leftResult != 0 ? leftResult : 0;
    // artText.printf("ArtDerivationAsTermRec() at node %d %s: unified child result is %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
    // childResult);

    // 4. If we are an intermediate node, then just propogate the childResult up
    if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE) {
      // artText.printf("ArtDerivationAsTermRec() at node %d %s: intermediate node returns %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
      // childResult);
      return childResult;
    }

    // 5. If we get here then we are a symbol node: do hats first
    if (children == parentChildren) { // we are folding
      if (fold == ARTFOLD_UNDER) {
        // artText.printf("ArtDerivationAsTermRec() at symbol node %d %s: fold under node returns zero%n", element,
        // artLabelInternalStrings[artSPPFNodeLabel(element)]);
        return 0;
      }
      if (fold == ARTFOLD_OVER) {
        int ret = childResult != 0 ? childResult : element;
        // artText.printf("ArtDerivationAsTermRec() at symbol node %d %s: fold over returns %d%n", element, artLabelInternalStrings[artSPPFNodeLabel(element)],
        // ret);
        return ret;
      }
    }

    // 6. If we get here then we are a nonfolding symbol node, so make a new term and insert it in the parent list
    int[] childrenArray = new int[children.size()]; // Build int[] from List<Integer>
    for (int i = 0; i < childrenArray.length; i++)
      childrenArray[i] = children.get(i);
    int newTermNode = childResult != 0 ? childResult : element;
    String symbolString = artLabelInternalStrings[artSPPFNodeLabel(newTermNode)];
    // Strip whitespace from builtins: use Java whitespace definition which is wrong in general
    if (artKindOfs[artSPPFNodeLabel(newTermNode)] == ARTK_BUILTIN_TERMINAL)
      symbolString = artLexeme(artSPPFNodeLeftExtent(newTermNode), artSPPFNodeRightExtent(newTermNode));

    // artLexer.artInputString.substring(artSPPFNodeLeftExtent(newTermNode), artSPPFNodeRightExtent(newTermNode)).strip();

    parentChildren.add(iTerms.findTerm(symbolString, childrenArray));
    // artText.printf("ArtDerivationAsTermRec() at symbol node %d %s: making new derivation tree node and returning zero%n", element,
    // artLabelInternalStrings[artSPPFNodeLabel(element)]);

    // artText.println("** at node " + element + " found term " + (parentChildren.get(parentChildren.size() - 1)) + ": "
    // + iTerms.toString(parentChildren.get(parentChildren.size() - 1)) + " and returning zero");
    return 0;
  }

  public int artDerivationAsTerm(ITerms iTerms) {
    artSPPFResetVisitedFlags();
    List<Integer> list = new LinkedList<>();
    artDerivationAsTermRec(artSPPFRoot(), list, iTerms, ARTFOLD_NONE);
    return list.get(0); // A little suprising... artDerivationAsTermRec gathers terms into the list; for the root that will be [s()]
  }

  private void artDerivationSelectFirstRec(int element) {
    // artText.printf("SelectFirstDerivationRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);
    artSPPFNodeSetSelected(element);

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) {
        artSPPFPackedNodeSetSelected(tmp);
        // artText.printf("Selecting element %d%n", tmp);
        int leftChild = artSPPFPackedNodeLeftChild(tmp);
        if (leftChild != 0) artDerivationSelectFirstRec(leftChild);
        artDerivationSelectFirstRec(artSPPFPackedNodeRightChild(tmp));
        break;
      }
  }

  @Override
  public void artSPPFSelectOne() {
    // System.out.println("sppfSelectOne");
    artSPPFResetVisitedFlags();
    artDerivationSelectFirstRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    artDerivationSelectCompleteTime = artReadClock();
  }

  private void artDerivationSelectAllRec(int element) {
    // text.printf(TextLevel.TRACE, "selectFirstDerivationRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // text.println(TextLevel.TRACE, "Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);
    artSPPFNodeSetSelected(element);

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (!artSPPFPackedNodeSuppressed(tmp)) {
        artSPPFPackedNodeSetSelected(tmp);
        int leftChild = artSPPFPackedNodeLeftChild(tmp);
        if (leftChild != 0) artDerivationSelectAllRec(leftChild);
        artDerivationSelectAllRec(artSPPFPackedNodeRightChild(tmp));
      }
  }

  @Override
  public void artDerivationSelectAll() {
    artSPPFResetVisitedFlags();
    artDerivationSelectAllRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
  }

  private void artDerivationSelectNextRec(int element) {
    /* Not yet implemented */
  }

  @Override
  public boolean artDerivationSelectNext() {
    artSPPFResetVisitedFlags();
    artDerivationSelectNextRec(artSPPFRoot());
    artSPPFResetVisitedFlags();
    return false;
  }

  /**********************************************/

  private int artRenderKind = artRenderKindIllegal;

  private final String artHiddenStyle = "style=filled fillcolor=yellow";
  private final String artSymbolNodeStyle = "";
  private final String artPackedNodeStyle = "style=rounded";
  private final String artIntermediateNodeStyle = "style=filled fillcolor=grey92";
  private final String artDerivationNodeStyle = "";

  private final String artAmbiguousStyle = "color=red";
  private final String artAllSuppressedStyle = "style=filled fillcolor=red";

  private final String artSuppressedStyle = "color=orange";
  private final String artSuppressedInTWEStyle = "color=magenta";
  private final String artInTWEStyle = "color=green3";
  private final String artSelectedStyle = "color=blue";

  private void artRenderSPPFNode(ARTText text, String title, String label, String style) {
    if (style != null) // In the new style, we only need to render nodes with non-default styles
      text.println("\"" + title + "\"[" + style + (label != null ? (" label = \"" + label + "\"") : "") + "]");
  }

  private void artRenderSPPFEdge(ARTText text, String elementLabel, String parentLabel, String style) {
    text.println("\"" + parentLabel + "\"->\"" + elementLabel + "\"" + " [" + style + "]");
  }

  private boolean artElementIsVisible(int element, boolean elementIsPacked) {
    switch (artRenderKind) {
    case artRenderKindDerivation:
      if (elementIsPacked) return false;

      if (!artSPPFNodeSelected(element)) return false;

      if (artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE) return false;

      return true;

    case artRenderKindSPPF:
      if (!elementIsPacked) return true;

      // This is the line that switches off display of packed nodes that have no siblings! AJ 24 October 2022
      return true; // artSPPFNodeArity(artSPPFPackedNodeParent(element)) > 1;

    default:
      return true;
    }
  }

  private boolean artElementIsRecursable(int element, boolean elementIsPacked) {
    switch (artRenderKind) {
    case artRenderKindDerivation:
      if (elementIsPacked)
        return artSPPFPackedNodeSelected(element);
      else
        return artSPPFNodeSelected(element);

    default:
      return true;
    }
  }

  private String artRenderSPPFNodeTitle(int element) {
    return element + ":" + getArtLabelInternalStrings()[artSPPFNodeLabel(element)] + "  " + artSPPFNodeLeftExtent(element) + ","
        + artSPPFNodeRightExtent(element);
  }

  private String artRenderSPPFPackedNodeTitle(int element) {
    if (element == 0) return "null";
    return element + ":" + getArtLabelInternalStrings()[artSPPFPackedNodeLabel(element)] + "  " + artSPPFPackedNodePivot(element);
  }

  private String artRenderGSSNodeTitle(int element) {
    return artGSSNodeLevel(element) + " " + getArtLabelInternalStrings()[artGSSNodeLabel(element)];
  }

  private void artWriteSPPFRec(ARTText text, int element, int parent, boolean parentIsPacked, int level, ARTLexerV3 tweSet) {
    if (artElementIsVisible(element, false) && parent != 0)
      artRenderSPPFEdge(text, artRenderSPPFNodeTitle(element), parentIsPacked ? artRenderSPPFPackedNodeTitle(parent) : artRenderSPPFNodeTitle(parent), "");

    if (artSPPFNodeVisited(element)) return;

    artSPPFNodeSetVisited(element);
    int newParent = parent;
    boolean newParentIsPacked = parentIsPacked;

    String style = artKindOfs[artSPPFNodeLabel(element)] == ARTK_INTERMEDIATE ? artIntermediateNodeStyle : artSymbolNodeStyle;
    if (artRenderKind == artRenderKindDerivation || artRenderKind == artRenderKindDerivationFull) style = artDerivationNodeStyle;

    if (tweSet != null) if (tweSet.isIn(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element)))
      if (tweSet.isSuppressed(artSPPFNodeLabel(element), artSPPFNodeLeftExtent(element), artSPPFNodeRightExtent(element)))
      style += (" " + artSuppressedInTWEStyle);
      else
      style += (" " + artInTWEStyle);

    if (artElementIsVisible(element, false)) {
      boolean allSuppressed = true;
      int packedNodeCount = 0;
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
        if (sppfHidden.contains(tmp)) continue;
        packedNodeCount++;
        if (!artSPPFPackedNodeSuppressed(tmp)) allSuppressed = false;
      }
      if (packedNodeCount > 1) style += (" " + artAmbiguousStyle);
      if (packedNodeCount > 0 && allSuppressed) style += (" " + artAllSuppressedStyle);
      artRenderSPPFNode(text, artRenderSPPFNodeTitle(element), null, style);
      newParent = element;
      newParentIsPacked = false;
    }

    if (artElementIsRecursable(element, false)) {
      for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
        if (artElementIsVisible(tmp, true)) {
          String pnStyle = "";

          if (sppfHidden.contains(tmp)) {
            // System.out.print("Rendering hidden node " + element);
            pnStyle += " " + artHiddenStyle;
          }

          artRenderSPPFNode(text, artRenderSPPFPackedNodeTitle(tmp), "" + artRenderSPPFPackedNodeTitle(tmp)/* artSPPFPackedNodePivot(tmp) */,
              artSPPFPackedNodeSelected(tmp) ? artPackedNodeStyle + " " + artSelectedStyle + pnStyle
                  : (artSPPFPackedNodeSuppressed(tmp) ? artPackedNodeStyle + " " + artSuppressedStyle + pnStyle : artPackedNodeStyle + pnStyle));

          // we can never have pack nodes visible unless their parent is visible
          artRenderSPPFEdge(text, artRenderSPPFPackedNodeTitle(tmp), artRenderSPPFNodeTitle(element), style);

          newParent = tmp;
          newParentIsPacked = true;
        }
        if (artElementIsRecursable(tmp, true)) {
          if (artSPPFPackedNodeLeftChild(tmp) != 0)
            artWriteSPPFRec(text, artSPPFPackedNodeLeftChild(tmp), newParent, newParentIsPacked, level == -1 ? level : level + 2, tweSet);
          artWriteSPPFRec(text, artSPPFPackedNodeRightChild(tmp), newParent, newParentIsPacked, level == -1 ? level : level + 2, tweSet);
        }
      }
    }
  }

  @Override
  public void artWriteSPPF(ARTText text, int renderKind, ARTLexerV3 tweSet) {
    this.artRenderKind = renderKind;

    if (renderKind == artRenderKindGSS) {
      artRenderSPPFNode(text, artRenderGSSNodeTitle(artRootGSSNode), null, "");
      for (int tmp = artGSSNodeFirst(); tmp != 0; tmp = artGSSNodeNext())
        artRenderSPPFNode(text, artRenderGSSNodeTitle(tmp), null, "");
      for (int tmp = artGSSEdgeFirst(); tmp != 0; tmp = artGSSEdgeNext())
        artRenderSPPFEdge(text, artRenderGSSNodeTitle(artGSSEdgeDestination(tmp)), artRenderGSSNodeTitle(artGSSEdgeSource(tmp)), "");
    } else if (renderKind == artRenderKindDerivation || renderKind == artRenderKindDerivationFull) {
      artWriteSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
    } else {
      artSPPFResetVisitedFlags();
      artWriteSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
      if (renderKind == artRenderKindSPPFFull)
        for (int element = artSPPFNodeFirst(); element != 0; element = artSPPFNodeNext())
          artWriteSPPFRec(text, element, 0, false, -1, tweSet);
      else if (renderKind == artRenderKindSPPF) artWriteSPPFRec(text, artSPPFRoot(), 0, false, 0, tweSet);
      artSPPFResetVisitedFlags();
    }
  }

  abstract protected void artInitialise();

  abstract protected void artParseBody(int nonterminalLabel);

  @Override
  public void artParse(String inputString, int nonterminalLabel, ARTGLLAttributeBlock startAttributes) {
    artInputString = inputString;
    artIsInLanguage = false;

    if (artKindOfs != null && artKindOfs[nonterminalLabel] != ARTK_NONTERMINAL) {
      System.out.println("Internal error: parse start label " + nonterminalLabel + " is not a nonterminal");
    }

    artInitialise();
    if (artDirectives.b("trace")) artTrace = 10;
    artParseBody(nonterminalLabel);

    if (artInadmissable) System.out.println("Specification inadmissable - EBNF not supported");
    if (artDirectives.b("smlCycleBreak")) smlCycleBreak();
    if (artDirectives.b("sppfCycleDetect")) sppfCycleDetect();

    if (artDirectives.b("sppfChooseCounts")) coreStatistics("Core statistics before SPPF chooser application", null);
    if (artDirectives.b("sppfAmbiguityAnalysis")) computeIsAmbiguous("Ambiguity relation analysis before SPPF chooser application");

    if (artDirectives.b("sppfShortest") || artDirectives.b("sppfLongest") || artDirectives.b("sppfPriority") || artDirectives.b("sppfDead")) artChoose();
    if (artDirectives.b("sppfChooseCounts")) coreStatistics("Core statistics after SPPF chooser application", null);
    if (artDirectives.b("sppfAmbiguityAnalysis")) computeIsAmbiguous("Ambiguity relation analysis after SPPF chooser application");

    if (artDirectives.b("sppfOrderedLongest")) artDisambiguateOrderedLongest();

    if (artDirectives.b("sppfSelectOne")) artSPPFSelectOne();

    if (artDirectives.b("tweFromSPPF")) if (!artIsInLanguage)
      System.out.println("tweFromSPPF skipped because of rejected string");
    else
      artSPPFCollectTWESet(true);

    if (tweSet != null) {
      tweSet.postProcess();
      if (artDirectives.b("sppfCountSentences")) SPPFCountSentences();
      if (artDirectives.b("tweTokenWrite") && tweSet != null) try {
        tweSet.printTWESet(new PrintStream(new File("ARTTokenGrammar.str")), false);
      } catch (FileNotFoundException e) {
        System.out.println("Unable to write term file 'ARTTokenGrammar.str'");
      }

    }

    String inputFilename = "";
    if (artDirectives.b("parseCounts")) {
      artComputeParseCounts();
      artLog(inputFilename, true);
      artLog(inputFilename, false);
    }

    if (artParserKind.indexOf("MGLL") != 0 && !artSPPFHasCycles) {
      // artDisambiguateOrderedLongest();
      artSPPFSelectOne();
      if (!artDirectives.b("actionSuppress")) artEvaluator(startAttributes);
    }

    if (artDirectives.b("sppfShowFull")) artWriteSPPF("sppfFull.dot", artRenderKindSPPFFull);
    if (artDirectives.b("sppfShow")) artWriteSPPF("sppf.dot", artRenderKindSPPF);
    if (artDirectives.b("gssShow")) artWriteSPPF("gss.dot", artRenderKindGSS);
    if (artDirectives.b("treeShow")) artWriteRDT("rdt.dot");
    if (artDirectives.b("treePrint")) artPrintRDT();
    if (artDirectives.b("termWrite") || artDirectives.b("termPrint")) {
      // Use new term library to create an ITerm from a derivation
      ITerms iTerms = new ITermsLowLevelAPI();
      String termString = iTerms.toString(artDerivationAsTerm(iTerms));

      if (artDirectives.b("termPrint")) System.out.println(termString);

      if (artDirectives.b("termWrite")) {
        try {
          PrintWriter pw;
          pw = new PrintWriter("artTerm.art");
          pw.println(termString);
          pw.close();
        } catch (FileNotFoundException e) {
          System.out.println("Unable to write term file 'artTerm.art'");
        }
      }
    }

  }

  /*
   * Cycle detection and breaking
   */
  Map<Integer, Set<Integer>> adjacencies;
  Set<Integer> sppfHidden = new HashSet<>();

  void addAdjacency(int parent, int child) { // update map, creating fresh set if necessary
    if (parent == 0) return; // No parent so do nothing

    if (adjacencies.get(parent) == null) adjacencies.put(parent, new HashSet<>());
    // System.out.println("Added adjacency " + parent + "->" + child);
    adjacencies.get(parent).add(child);
  }

  private void addAdjacencies(int parentSPPFNode, int symbolNode) { // add in children of childSymbolNode
    if (symbolNode != 0) {
      for (int tmp = artSPPFNodePackedNodeList(symbolNode); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
        if (!artSPPFPackedNodeSuppressed(tmp)) addAdjacency(parentSPPFNode, tmp);
      }
    }
  }

  private void sppfCycleDetectLoadImmediateAdjacenciesRec(int element) {
    // artText.printf("sppfCycleDetectLoadImmediateAdjacenciesRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);

    // Load unsuppressed adjacencies
    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp) || sppfHidden.contains(tmp)) continue;
      addAdjacencies(tmp, artSPPFPackedNodeLeftChild(tmp));
      addAdjacencies(tmp, artSPPFPackedNodeRightChild(tmp));
    }

    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeSuppressed(tmp) || sppfHidden.contains(tmp)) continue;
      int leftChild = artSPPFPackedNodeLeftChild(tmp);
      if (leftChild != 0) sppfCycleDetectLoadImmediateAdjacenciesRec(leftChild); // recurse

      sppfCycleDetectLoadImmediateAdjacenciesRec(artSPPFPackedNodeRightChild(tmp)); // recurse
    }
  }

  protected void sppfCycleDetect() {
    // 0. clear all visited flags
    artSPPFResetVisitedFlags();
    adjacencies = new HashMap<>();
    artSPPFHasCycles = false;

    // 1. Load direct adjacencies
    sppfCycleDetectLoadImmediateAdjacenciesRec(artSPPFRoot());

    // System.out.println("Initial adjacency relation " + adjacencies);

    // 2. Form transitive closure brute force
    boolean changed;
    while (true) {
      changed = false;

      for (Integer i : adjacencies.keySet()) {
        Set<Integer> newTargets = new HashSet<>();
        for (Integer j : adjacencies.get(i))
          if (adjacencies.get(j) != null) newTargets.addAll(adjacencies.get(j));
        newTargets.removeAll(adjacencies.get(i));

        if (newTargets.size() != 0) {
          changed = true;
          adjacencies.get(i).addAll(newTargets);
        }
      }
      if (!changed) break;
    }

    // System.out.println("Transitively closed adjacency relation " + adjacencies);

    // 3. Set global flag
    for (Integer i : adjacencies.keySet())
      if (adjacencies.get(i).contains(i)) artSPPFHasCycles = true;

    if (artSPPFHasCycles)
      System.out.println("SPPF has cycles");
    else
      System.out.println("SPPF has no cycles");

    // 4. (Optionally) report self loops in transitive closure
    Set<Integer> cycleNodes = new HashSet<>();

    for (Integer i : adjacencies.keySet())
      if (adjacencies.get(i).contains(i)) {
        System.out.println("Node " + i + ": " + artLabelInternalStrings[artSPPFPackedNodeLabel(i)] + "is in a cycle");
        cycleNodes.add(artSPPFPackedNodeLabel(i));
      }

    for (int i : cycleNodes)
      System.out.println("Slot " + i + ": " + artLabelInternalStrings[i] + " is in a cycle");

  }

  /* This is an SML specific set of cycle breaking rules */
  int dec__Label, scolonOp__Label, spec__Label, strdec__Label, topdec__Label, topdecOp__Label;

  int dec__dec_scolonOp_dot_dec__Label, dec__dec_scolonOp_dec_dot__Label, spec__spec_scolonOp_dot_spec__Label, spec__spec_scolonOp_spec_dot__Label,
      strdec__strdec_scolonOp_dot_strdec__Label, strdec__strdec_scolonOp_strdec_dot__Label,

      topdec__strdec_topdecOp_dot__Label, topdecOp__topdec_dot__Label;

  protected void smlCycleBreakRec(int element) {
    // artText.printf("smlCycleBreakRec() at node %d%n", element);

    if (artSPPFNodeVisited(element)) {
      // artText.println("Already visited - aborting");
      return;
    }

    artSPPFNodeSetVisited(element);
    /*
     * Adrian's conditions for hiding a node as modified 18 January 2023
     *
     *
     * 1. For node (dec, i, j) with child X = (dec ::= dec scolonOp dec . , i), hide X
     *
     * 2. For node (dec, i, j) with grandchild X = (dec ::= dec scolonOp . dec, i, j), if X has child Y = (dec::=dec scolonOp . dec , j) and Y has child
     * (scolonOp, j, j), hide Y
     *
     * 3. For node (spec, i, j) with child X = (spec::= spec scolonOp spec . , i), hide X
     *
     * 4. For node (spec, i, j) with grandchild X = (spec ::= spec scolonOp . spec, i, j), if X has child Y = (spec::=spec scolonOp . spec , j) and Y has child
     * (scolonOp, j, j), hide Y
     *
     * 5. For node (strdec, i, j) with child X = (strdec::= strdec scolonOp strdec . , i), hide X
     *
     * 6. For node (strdec, i, j) with grandchild X = (strdec ::= strdec scolonOp . strdec, i, j), if X has child Y = (strdec::=strdec scolonOp . strdec , j)
     * and Y has child (scolonOp, j, j), hide Y
     *
     * 7. For node (topdec, i, j) with i != j and with child X = (topdec::= strdec topdecOp . , i), hide X
     *
     * 8. For node (topdecOp, i, j) with i = j and with child X = (topdecOp ::= topdec . , i), hide X x *
     */

    // if (element == 28446) {
    // System.out.println("Bang! at 28446");
    // }

    int elementLabel = artSPPFNodeLabel(element);
    int i = artSPPFNodeLeftExtent(element);
    int j = artSPPFNodeRightExtent(element);

    if (elementLabel == dec__Label) {
      childCheck(element, dec__dec_scolonOp_dec_dot__Label, i); // 1.
      // deepChildCheck(element, dec__dec_scolonOp_dot_dec__Label, i, j, dec__dec_scolonOp_dot_dec__Label, j, scolonOp__Label, j, j); // 2.
      deepChildCheckNEW(element, dec__dec_scolonOp_dec_dot__Label, j, dec__dec_scolonOp_dot_dec__Label, i, j, dec__dec_scolonOp_dot_dec__Label, j); // 2.
    }

    if (elementLabel == spec__Label) {
      childCheck(element, spec__spec_scolonOp_spec_dot__Label, i); // 3.
      // deepChildCheck(element, spec__spec_scolonOp_dot_spec__Label, i, j, spec__spec_scolonOp_dot_spec__Label, j, scolonOp__Label, j, j); // 4.
      deepChildCheckNEW(element, spec__spec_scolonOp_spec_dot__Label, j, spec__spec_scolonOp_dot_spec__Label, i, j, spec__spec_scolonOp_dot_spec__Label, j); // 4.
    }

    if (elementLabel == strdec__Label) {
      childCheck(element, strdec__strdec_scolonOp_strdec_dot__Label, i); // 5.
      // deepChildCheck(element, strdec__strdec_scolonOp_dot_strdec__Label, i, j, strdec__strdec_scolonOp_dot_strdec__Label, j, scolonOp__Label, j, j); // 6.
      deepChildCheckNEW(element, strdec__strdec_scolonOp_strdec_dot__Label, j, strdec__strdec_scolonOp_dot_strdec__Label, i, j,
          strdec__strdec_scolonOp_dot_strdec__Label, j); // 6.
    }

    if (elementLabel == topdec__Label && i != j) childCheck(element, topdec__strdec_topdecOp_dot__Label, i); // 7.

    if (elementLabel == topdecOp__Label && i == j) childCheck(element, topdecOp__topdec_dot__Label, i); // 8.

    // Recursion
    for (int tmp = artSPPFNodePackedNodeList(element); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {

      int leftChild = artSPPFPackedNodeLeftChild(tmp);
      if (leftChild != 0) smlCycleBreakRec(leftChild); // recurse

      smlCycleBreakRec(artSPPFPackedNodeRightChild(tmp)); // recurse
    }
  }

  private void updateHidden(int element) {
    // System.out.println("Hiding node " + element);
    sppfHidden.add(element);
  }

  private void childCheck(int symbolNode, int childLabel, int childPivot) {
    // System.out.println("childCheck on " + symbolNode);
    for (int tmp = artSPPFNodePackedNodeList(symbolNode); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) { // Iterate over child packed nodes
      // Check children of symbol node for child
      // System.out.println("childChecking " + tmp);
      if (artSPPFPackedNodeLabel(tmp) == childLabel && artSPPFPackedNodePivot(tmp) == childPivot) updateHidden(tmp);
    }
  }

  private void deepChildCheckNEW(int symbolNode, int childLabel, int childPivot, int grandChildLabel, int grandChildLeftExtent, int grandChildRightExtent,
      int greatGrandChildLabel, int greatGrandChildPivot) {
    for (int tmp = artSPPFNodePackedNodeList(symbolNode); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp))
      if (artSPPFPackedNodeLabel(tmp) == childLabel && artSPPFPackedNodePivot(tmp) == childPivot) {

        deepGrandChildCheckNEW(tmp, artSPPFPackedNodeLeftChild(tmp), grandChildLabel, grandChildLeftExtent, grandChildRightExtent, greatGrandChildLabel,
            greatGrandChildPivot);
        deepGrandChildCheckNEW(tmp, artSPPFPackedNodeRightChild(tmp), grandChildLabel, grandChildLeftExtent, grandChildRightExtent, greatGrandChildLabel,
            greatGrandChildPivot);
      }
  }

  private void deepGrandChildCheckNEW(int xNode, int grandChildNode, int grandChildLabel, int grandChildLeftExtent, int grandChildRightExtent,
      int greatGrandChildLabel, int greatGrandChildPivot) {
    if (grandChildNode == 0) return;
    if (!(artSPPFNodeLabel(grandChildNode) == grandChildLabel && artSPPFNodeLeftExtent(grandChildNode) == grandChildLeftExtent
        && artSPPFNodeRightExtent(grandChildNode) == grandChildRightExtent))
      return;

    boolean first = true;
    for (int tmp = artSPPFNodePackedNodeList(grandChildNode); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) {
      if (artSPPFPackedNodeLabel(tmp) == greatGrandChildLabel && artSPPFPackedNodePivot(tmp) == greatGrandChildPivot) {
        if (first && artSPPFPackedNodePackedNodeList(tmp) == 0) // Are we a singleton packed node
          sppfHidden.add(xNode);
        else
          sppfHidden.add(tmp);
      }
      first = false;
    }
  }
  // // Iterate over children and their children, calling subChildCheck on each
  // private void deepChildCheck(int symbolNode, int grandChildLabel, int grandChildLeftExtent, int grandChildRightExtent, int greatGrandChildLabel,
  // int greatGrandChildPivot, int greatGreatGrandChildLabel, int greatGreatGrandChildLeftExtent, int greatGreatGrandChildRightExtent) {
  // // System.out.println("deepChildCheck on " + symbolNode);
  // for (int tmp = artSPPFNodePackedNodeList(symbolNode); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) { // Iterate over child packed nodes
  // // System.out.println("deepChildChecking " + tmp);
  // int leftChild = artSPPFPackedNodeLeftChild(tmp);
  // if (leftChild != 0) deepGrandChildCheck(leftChild, grandChildLabel, grandChildLeftExtent, grandChildRightExtent, greatGrandChildLabel,
  // greatGrandChildPivot, greatGreatGrandChildLabel, greatGreatGrandChildLeftExtent, greatGreatGrandChildRightExtent);
  // deepGrandChildCheck(artSPPFPackedNodeRightChild(tmp), grandChildLabel, grandChildLeftExtent, grandChildRightExtent, greatGrandChildLabel,
  // greatGrandChildPivot, greatGreatGrandChildLabel, greatGreatGrandChildLeftExtent, greatGreatGrandChildRightExtent);
  // }
  // }
  //
  // // We know only that we are a grandchild of _dec, i, j; check that we have the right lanel to be an X and then iterate over children subsubChildCheck
  // private void deepGrandChildCheck(int grandChildNode, int grandChildLabel, int grandChildLeftExtent, int grandChildRightExtent, int greatGrandChildLabel,
  // int greatGrandChildPivot, int greatGreatGrandChildLabel, int greatGreatGrandChildLeftExtent, int greatGreatGrandChildrightExtent) {
  // // System.out.println("deepGrandChildCheck on " + grandChildNode);
  // if (!(artSPPFNodeLabel(grandChildNode) == grandChildLabel && artSPPFNodeLeftExtent(grandChildNode) == grandChildLeftExtent
  // && artSPPFNodeRightExtent(grandChildNode) == grandChildRightExtent))
  // return;
  //
  // for (int tmp = artSPPFNodePackedNodeList(grandChildNode); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) { // Iterate over child packed nodes
  // if (artSPPFPackedNodeLabel(tmp) == greatGrandChildLabel && artSPPFPackedNodePivot(tmp) == greatGrandChildPivot) {
  // if (greatGreatGrandChildCheck(artSPPFPackedNodeLeftChild(tmp), greatGreatGrandChildLabel, greatGreatGrandChildLeftExtent,
  // greatGreatGrandChildrightExtent))
  // updateHidden(tmp);
  // if (greatGreatGrandChildCheck(artSPPFPackedNodeRightChild(tmp), greatGreatGrandChildLabel, greatGreatGrandChildLeftExtent,
  // greatGreatGrandChildrightExtent))
  // updateHidden(tmp);
  // }
  // }
  // }
  //
  // private boolean greatGreatGrandChildCheck(int greatGreatGrandChildNode, int greatGreatGrandChildLabel, int greatGreatGrandChildLeftExtent,
  // int greatGreatGrandChildRightExtent) {
  // // System.out.println("deepGreatGreatGrandChildCheck on " + greatGreatGrandChildNode);
  // return (greatGreatGrandChildNode != 0 && artSPPFNodeLabel(greatGreatGrandChildNode) == greatGreatGrandChildLabel
  // && artSPPFNodeLeftExtent(greatGreatGrandChildNode) == greatGreatGrandChildLeftExtent
  // && artSPPFNodeRightExtent(greatGreatGrandChildNode) == greatGreatGrandChildRightExtent);
  // }

  // private boolean grandChildCheck(int symbolNode, int targetSymbolNodeLabel, int targetSymbolNodeLeftExtent, int targetSymbolNodeRightExtent) {
  // for (int tmp = artSPPFNodePackedNodeList(symbolNode); tmp != 0; tmp = artSPPFPackedNodePackedNodeList(tmp)) { // Iterate over child packed nodes
  // int leftChild = artSPPFPackedNodeLeftChild(tmp);
  // if (leftChild != 0 && artSPPFNodeLabel(leftChild) == targetSymbolNodeLabel && artSPPFNodeLeftExtent(leftChild) == targetSymbolNodeLeftExtent
  // && artSPPFNodeRightExtent(leftChild) == targetSymbolNodeRightExtent)
  // return true;
  // int rightChild = artSPPFPackedNodeRightChild(tmp);
  // if (artSPPFNodeLabel(rightChild) == targetSymbolNodeLabel && artSPPFNodeLeftExtent(rightChild) == targetSymbolNodeLeftExtent
  // && artSPPFNodeRightExtent(rightChild) == targetSymbolNodeRightExtent)
  // return true;
  // }
  // return false;
  // }
  //

  protected void smlCycleBreak() {
    artSPPFResetVisitedFlags();
    sppfHidden = new HashSet<>();

    dec__Label = findLabel("dec");
    scolonOp__Label = findLabel("scolonOp");

    spec__Label = findLabel("spec");
    strdec__Label = findLabel("strdec");
    topdec__Label = findLabel("topdec");
    topdecOp__Label = findLabel("topdecOp");

    dec__dec_scolonOp_dot_dec__Label = findLabel("dec ::= dec scolonOp . dec ");
    dec__dec_scolonOp_dec_dot__Label = findLabel("dec ::= dec scolonOp dec .");
    spec__spec_scolonOp_dot_spec__Label = findLabel("spec ::= spec scolonOp . spec ");
    spec__spec_scolonOp_spec_dot__Label = findLabel("spec ::= spec scolonOp spec .");
    strdec__strdec_scolonOp_dot_strdec__Label = findLabel("strdec ::= strdec scolonOp . strdec ");
    strdec__strdec_scolonOp_strdec_dot__Label = findLabel("strdec ::= strdec scolonOp strdec .");
    topdec__strdec_topdecOp_dot__Label = findLabel("topdec ::= strdec topdecOp .");
    topdecOp__topdec_dot__Label = findLabel("topdecOp ::= topdec .");

    smlCycleBreakRec(artSPPFRoot());
  }

  private int findLabel(String str) {
    for (int i = 0; i < artLabelInternalStrings.length; i++)
      if (artLabelInternalStrings[i] != null && artLabelInternalStrings[i].equals(str)) return i;

    System.out.println("No level index found for " + str);
    return 0;
  }

  protected int artNextFreeNodeNumber = 1;
  protected String artInputString;

  @Override
  public void artEvaluator(ARTGLLAttributeBlock artAttributes) {
    artRDT = new ARTGLLRDT("RDT", artKindOfs, artLabelStrings, artInputString);
    ARTGLLRDTVertex artNewParent = new ARTGLLRDTVertex(artNextFreeNodeNumber++,
        new ARTGLLRDTPayload(artRDT, artSPPFNodeLeftExtent(artRootSPPFNode), artSPPFNodeRightExtent(artRootSPPFNode), artSPPFNodeLabel(artRootSPPFNode), null));
    artRDT.setRoot(artNewParent);
    boolean artNewWriteable = true;
    artEvaluate(new ARTGLLRDTHandle(artRootSPPFNode), artAttributes, artNewParent, artNewWriteable);
    artAttributeEvaluateCompleteTime = artReadClock();
  }

  @Override
  public void artWriteRDT(String filename) {
    artRDT.printDot(filename);
  }

  @Override
  public void artPrintRDT() {
    artPrintRDTRec(artRDT, artRDT.getRoot(), 0);
  }

  private void artPrintRDTRec(ARTGLLRDT tree, ARTGLLRDTVertex vertex, int level) {
    if (vertex == null) return;
    // Preorder printout
    for (int i = 0; i < level; i++)
      System.out.print("  ");
    System.out.printf("%d: %s%n", vertex.getKey(), vertex.getPayload().toString(tree));
    artPrintRDTRec(tree, vertex.getChild(), level + 1);
    artPrintRDTRec(tree, vertex.getSibling(), level);
  }

  /* Support for TWE sets below this line */
  protected class ARTRightExtentNode {
    public int rightExtent;
    public ARTRightExtentNode next;

    ARTRightExtentNode(int rightExtent, ARTRightExtentNode next) {
      this.rightExtent = rightExtent;
      this.next = next;
    }

  }

  private boolean artContains(int rightExtent, ARTRightExtentNode list) {
    while (list != null)
      if (list.rightExtent == rightExtent)
        return true;
      else
        list = list.next;
    return false;
  }

  protected ARTRightExtentNode[][] artTriples; // Indexed as leftExtent, token, rightExtent
  // shortcut to access the elements in classical GLL
  public int artInputSuccessorBuffer[]; // Holds runs of successor handles; each run is terminated by -1

  private void artLexBuildTriplesFromTWESet() {
    // First dimension is the index into the input
    // Second dimension is the token
    // Third dimension is the sequence of right extents
    artTriples = new ARTRightExtentNode[artLexer.artInputLength + 1][];
    System.out.println("Initialised artTriples to length " + artTriples.length);
    int indexedTWESet[][][] = artLexer.lexicaliseToIndexedTWESet(artLexer.artInputString);
    for (int i = 0; i < indexedTWESet.length; i++) {
      if (artTriples[i] == null) artTriples[i] = new ARTRightExtentNode[artTokenExtent];
      for (int token = 0; token < indexedTWESet[i].length; token++)
        for (int jIndex = 0; jIndex < indexedTWESet[i][token].length; jIndex++)
          artTriples[i][token] = new ARTRightExtentNode(indexedTWESet[i][token][jIndex], artTriples[i][token]);
    }
  }

  protected int artLexBuildTriplesFromFile(String filename) {
    int[][][] tweSet;
    try {
      tweSet = artLexer.readIndexedTWESet(filename);
    } catch (FileNotFoundException e1) {
      throw new ARTUncheckedException("Unable to open TWE set file '" + filename + "'");
    }

    // Constants representing the length of the dimensions; in Java these are not required since we could interrogate the array objects, but we want
    // compatibility with C and non-OO lanuages
    artTriples = new ARTRightExtentNode[tweSet.length + 1][];
    artLexer.artInputIndex = 0;
    artLexer.artInputLength = tweSet.length - 2;
    for (int i = 0; i < tweSet.length; i++) {
      for (int t = 0; t < tweSet[0].length; t++)

        if (tweSet[i][t] != null) for (int e = 0; e < tweSet[i][t].length; e++) {
          if (artTriples[i] == null) artTriples[i] = new ARTRightExtentNode[tweSet[0].length];
          if (!artContains(artLexer.artInputIndex, artTriples[i][t])) {
            artTriples[i][t] = new ARTRightExtentNode(tweSet[i][t][e], artTriples[i][t]);
            // System.out.println("Added " + t + " with extents " + i + ", " + tweSet[i][t][e]);
          }
        }
    }

    if (artDirectives.b("inputPrint")) {
      System.out.println("TWE set as loaded by MGLL parser");
      artPrintTriples();
    }
    return artLexer.getEosWhitespacePrefix();
  }

  private void artPrintTriples() {
    if (artTriples == null) return;
    // Now print out the triples
    for (int i = 0; i < artTriples.length; i++) {
      if (artTriples[i] != null) {
        System.out.print(i + ": ");
        for (int t = 0; t < artTriples[i].length; t++)
          for (ARTRightExtentNode n = artTriples[i][t]; n != null; n = n.next)
            System.out.print(" " + artLabelInternalStrings[t] + "." + n.rightExtent);
        System.out.println();
      }
    }
  }

  protected void artLexBuildSuccessorSets() {
    // Populate the visible data structures which represnet the \Chi_{a,i} sets using the triples array, which may be discarded after this phase
    // These are the data structures to be constructed:
    // int InputPairBuffer[]; // Holds all unique input pairs; index into this buffer of a pair (a,i) is its handle in descriptors
    // int InputPairIndex[][]; // Index of input pairs: contents of location (a, i) is the address of (a,i) in InputPair Buffer, a.k.a the pair's handle
    // int InputInitialPairBuffer[]; // Holds pair handles for state 0
    // int inputSuccessorPairs[][][]; //Blocks of successor pairs for each (a, i) - these are the \Chi_{a,i} sets from the paper as lists of pair handles

    // Enumerate unique pairs
    int pairCardinality = 0;
    for (int leftExtent = 0; leftExtent < artTriples.length; leftExtent++)
      if (artTriples[leftExtent] != null) for (int tokenNumber = 0; tokenNumber < artTriples[leftExtent].length; tokenNumber++)
        if (artTriples[leftExtent][tokenNumber] != null) pairCardinality++;

    // Construct sparse map from pairs to integers and store pairs in pairs buffer; create InputSuccessorIndex as we go
    artInputPairBuffer = new int[pairCardinality * 2];
    artInputPairIndex = new int[artTriples.length + 1][];
    artInputFirstPairAtLeftExtent = new int[artTriples.length + 1];
    artInputSuccessorIndex = new int[artTriples.length + 1][];
    pairCardinality = 0;
    for (int leftExtent = 0; leftExtent < artTriples.length; leftExtent++) {
      if (artTriples[leftExtent] == null) continue;
      artInputPairIndex[leftExtent] = new int[artTokenExtent];
      artInputSuccessorIndex[leftExtent] = new int[artTokenExtent];
      artInputFirstPairAtLeftExtent[leftExtent] = pairCardinality; // This index is used by classical GLL to fetch tokens from the input pair buffer
      for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++) {
        // System.out.println("artTokenExtent = " + artTokenExtent + " artTriples.length = " + artTriples.length + " leftExtent = " + leftExtent
        // + " tokenNumber = " + tokenNumber + " block length = " + artTriples[leftExtent].length);
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this position
        artInputPairIndex[leftExtent][tokenNumber] = pairCardinality;
        artInputPairBuffer[pairCardinality++] = tokenNumber;
        artInputPairBuffer[pairCardinality++] = leftExtent;
        if (ARTTRACETWE) System.out.printf("Loaded pair (%s,%d) to inputPairBuffer[%d]\n", artLabelStrings[tokenNumber], leftExtent,
            artInputPairIndex[leftExtent][tokenNumber]);
      }
    }

    // Enumerate successorBuffer
    int successorBufferCardinality = 0;
    if (artTriples[0] != null) for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++)
      if (artTriples[0][tokenNumber] != null) {
        if (ARTTRACETWE) System.out.printf("Initial pair search found token %s\n", artLabelStrings[tokenNumber]);
        successorBufferCardinality++;
      }

    successorBufferCardinality++; // leave a space for the terminating -1

    if (ARTTRACETWE) System.out.printf("Initial pair cardinality: %d\n", successorBufferCardinality);

    // Now add in the cardinalities of the successor blocks
    for (int leftExtent = 0; leftExtent < artTriples.length; leftExtent++) {
      if (artTriples[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

      for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++) {
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this leftExtent position

        if (ARTTRACETWE) System.out.printf("Counting successors for pair(%s, %d)\n", artLabelStrings[tokenNumber], leftExtent);
        successorBufferCardinality++; // leave a space for the terminating -1

        for (ARTRightExtentNode tmp = artTriples[leftExtent][tokenNumber]; tmp != null; tmp = tmp.next) {
          int rightExtent = tmp.rightExtent;

          if (ARTTRACETWE) System.out.printf("Pair(%s, %d) has rightExtent %d\n", artLabelStrings[tokenNumber], leftExtent, rightExtent);

          // Now scan destination state for all of its tokens
          if (artTriples[rightExtent] != null) // There may be no out edges at all; certain for the last state
            for (int successorTokenNumber = 0; successorTokenNumber < artTokenExtent; successorTokenNumber++) {
              if (artTriples[rightExtent][successorTokenNumber] == null) continue;
              successorBufferCardinality++;
              if (ARTTRACETWE) System.out.printf("Pair(%s, %d) has successor (%s, %d)\n", artLabelStrings[tokenNumber], leftExtent,
                  artLabelStrings[successorTokenNumber], rightExtent);
            }
        }
      }
    }

    if (ARTTRACETWE) System.out.printf("Successor buffer cardinality: %d\n", successorBufferCardinality);

    // Allocate successor buffer
    artInputSuccessorBuffer = new int[successorBufferCardinality];

    // Load successorBuffer with initial pairs
    successorBufferCardinality = 0;
    if (artTriples[0] != null) for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++)
      if (artTriples[0][tokenNumber] != null) artInputSuccessorBuffer[successorBufferCardinality++] = artInputPairIndex[0][tokenNumber];

    artInputSuccessorBuffer[successorBufferCardinality++] = -1; // Terminate initial block

    // Load successorBuffer with successor blocks, indexing as we go
    for (int leftExtent = 0; leftExtent < artTriples.length; leftExtent++) {
      if (artTriples[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

      for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++) {
        if (artTriples[leftExtent][tokenNumber] == null) continue; // There are no instances of this token leaving this leftExtent position

        artInputSuccessorIndex[leftExtent][tokenNumber] = successorBufferCardinality;

        if (ARTTRACETWE) System.out.printf("Loading successors for pair(%s, %d) to successorBufferlocation \n", artLabelStrings[tokenNumber], leftExtent);

        for (ARTRightExtentNode tmp = artTriples[leftExtent][tokenNumber]; tmp != null; tmp = tmp.next) {
          int rightExtent = tmp.rightExtent;

          // Now scan destination state for all of its tokens
          if (artTriples[rightExtent] != null) // There may be no out edges at all; certain for the last state
            for (int successorTokenNumber = 0; successorTokenNumber < artTokenExtent; successorTokenNumber++) {
              if (artTriples[rightExtent][successorTokenNumber] == null) continue;
              artInputSuccessorBuffer[successorBufferCardinality++] = artInputPairIndex[rightExtent][successorTokenNumber];

              if (ARTTRACETWE) System.out.printf("Loaded pair(%s, %d) successor (%s, %d) to InputSuccessorBuffer[%d]\n", artLabelStrings[tokenNumber],
                  leftExtent, artLabelStrings[successorTokenNumber], rightExtent, successorBufferCardinality - 1);
            }
        }
        artInputSuccessorBuffer[successorBufferCardinality++] = -1; // Terminate initial block
      }
    }

    // Dump successorBuffer
    if (ARTTRACETWE) {
      for (int i = 0; artInputSuccessorBuffer[i] != -1; i++)
        System.out.printf("Initial pair [%d](%s, %d)\n", i, artLabelStrings[artInputPairBuffer[artInputSuccessorBuffer[i]]],
            artInputPairBuffer[artInputSuccessorBuffer[i] + 1]);

      for (int leftExtent = 0; leftExtent < artTriples.length + 1; leftExtent++) {
        if (artInputSuccessorIndex[leftExtent] == null) continue; // There are no tokens leaving this leftExtent position

        for (int tokenNumber = 0; tokenNumber < artTokenExtent; tokenNumber++) {
          if (artInputSuccessorIndex[leftExtent][tokenNumber] == 0) continue; // There are no instances of this token leaving this leftExtent position
          for (int i = artInputSuccessorIndex[leftExtent][tokenNumber]; artInputSuccessorBuffer[i] != -1; i++)
            System.out.printf("Pair (%s, %d) has successor %d:(%s, %d)\n", artLabelStrings[tokenNumber], leftExtent, i,
                artLabelStrings[artInputPairBuffer[artInputSuccessorBuffer[i]]], artInputPairBuffer[artInputSuccessorBuffer[i] + 1]);
        }
      }
    }
  }

  public void artLexDump(String string) {// dump pair buffer
    System.out.println(string);
    if (artInputPairBuffer == null) return;
    for (int i = 0; i < artInputPairBuffer.length - 2; i += 2)
      System.out.printf("%d: %d %s %s\n", i, artInputPairBuffer[i + 1], artLabelStrings[artInputPairBuffer[i]],
          artLexer.artInputString.substring(artInputPairBuffer[i + 1], artInputPairBuffer[i + 3]).trim());
  }

  // This is the lexer interface used by classicial GLL
  public void artLexicaliseForV3GLL(String stringInput, String filename) {
    // System.out.println("**** Start of front end lexer");
    artLexer.artInputString = stringInput + "\0";
    artLexer.artLoadInputArray(stringInput);
    artLexer.artInputLength = artLexer.artInputString.length();
    artTokenExtent = ARTGLLParserBase.ARTL_EPSILON;

    artTriples = new ARTRightExtentNode[artLexer.artInputLength + 1][];

    if (filename != null) {
      artWhitespaceEOSPrefixLength = artLexBuildTriplesFromFile(filename);
    } else {
      boolean suppressWhitespace = true;
      int leftExtent;

      artLexer.artInputIndex = 0;
      do {
        leftExtent = artLexer.artInputIndex;
        if (suppressWhitespace) artLexer.artLexicalisePreparseWhitespace();
        artLexer.artMatchLongestRaw();
        suppressWhitespace = artKindOfs[artLexer.artLongestToken] != ARTGLLParserBase.ARTK_CHARACTER_TERMINAL;

        if (artTriples[leftExtent] == null) artTriples[leftExtent] = new ARTRightExtentNode[artTokenExtent];

        // System.out.println("** Adding " + artLexer.artLongestToken + " " + artLabelInternalStrings[artLexer.artLongestToken] + " with extents " + leftExtent
        // + ", " + artLexer.artInputIndex);

        if (!artContains(artLexer.artInputIndex, artTriples[leftExtent][artLexer.artLongestToken]))
          artTriples[leftExtent][artLexer.artLongestToken] = new ARTRightExtentNode(artLexer.artInputIndex, artTriples[leftExtent][artLexer.artLongestToken]); // Head
      } while (artLexer.artLongestToken != ARTGLLParserBase.ARTL_EOS);
      artWhitespaceEOSPrefixLength = artLexer.artInputLength - leftExtent;
    }
    // System.out.println("Triples from longest match front end");
    // artPrintTriples();
    artLexBuildSuccessorSets();
    // System.out.println("Lexer dump after building the successor sets");
    // artLexDump("lexical dump longest match");
    // System.out.println("**** End of front end lexer");
  }
}
